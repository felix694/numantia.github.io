<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://numantia.github.io</id>
    <title>云杉的速记</title>
    <updated>2021-06-28T05:15:48.368Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://numantia.github.io"/>
    <link rel="self" href="https://numantia.github.io/atom.xml"/>
    <subtitle>开放和共享思考，力争简化复杂，复杂天真</subtitle>
    <logo>https://numantia.github.io/images/avatar.png</logo>
    <icon>https://numantia.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 云杉的速记</rights>
    <entry>
        <title type="html"><![CDATA[VS Code 快捷键和用法]]></title>
        <id>https://numantia.github.io/post/vscode-keyboard-shorcut/</id>
        <link href="https://numantia.github.io/post/vscode-keyboard-shorcut/">
        </link>
        <updated>2021-06-25T04:00:44.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%BC%96%E8%BE%91-basic-editing">基础编辑 Basic editing</a></li>
<li><a href="#%E5%AF%BC%E8%88%AA-navigation">导航 Navigation</a></li>
<li><a href="#%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2-search-and-replace">搜索和替换 Search and replace</a></li>
<li><a href="#%E5%A4%9A%E5%85%89%E6%A0%87%E5%92%8C%E9%80%89%E6%8B%A9-multi-cursor-and-selection">多光标和选择 Multi-cursor and selection</a></li>
<li><a href="#%E4%B8%B0%E5%AF%8C%E7%9A%84%E8%AF%AD%E8%A8%80%E7%BC%96%E8%BE%91-rich-languages-editing">丰富的语言编辑 Rich languages editing</a></li>
<li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8%E7%AE%A1%E7%90%86-editor-management">编辑器管理 Editor management</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-file-management">文件管理 File management</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA-display">显示 Display</a></li>
<li><a href="#%E8%B0%83%E8%AF%95-debug">调试 Debug</a></li>
<li><a href="#%E9%9B%86%E6%88%90%E7%BB%88%E7%AB%AF-integrated-terminal">集成终端 Integrated terminal</a></li>
</ul>
</li>
</ul>
</p>
<p>本篇文章用作个人快捷键备忘，不求全面，若您本意是想找到特定快捷键，可以点击 <code>菜单栏 &gt; help &gt; Keyboard Shortcuts Reference</code> , Window常用快捷键可以点击该<a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">链接</a>，若想查看中文版本，该篇<a href="https://blog.csdn.net/p358278505/article/details/74221214">博文</a>有详细说明。</p>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl + Shift + P，F1</td>
<td style="text-align:left">显示命令面板 Show Command Palette</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + P</td>
<td style="text-align:left">快速打开 Quick Open</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + N</td>
<td style="text-align:left">新窗口/实例 New window/instance</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + W</td>
<td style="text-align:left">关闭窗口/实例 Close window/instance</td>
</tr>
</tbody>
</table>
<h2 id="基础编辑-basic-editing">基础编辑 Basic editing</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl+X</td>
<td style="text-align:left">剪切行（空选定） Cut line (empty selection)</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+C</td>
<td style="text-align:left">复制行（空选定）Copy line (empty selection)</td>
</tr>
<tr>
<td style="text-align:left">Shift+Alt + ↓ / ↑</td>
<td style="text-align:left">向上/向下复制行 Copy line up/down</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+K</td>
<td style="text-align:left">删除行 Delete line</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Enter</td>
<td style="text-align:left">在下面插入行 Insert line below</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+Enter</td>
<td style="text-align:left">在上面插入行 Insert line above</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+[</td>
<td style="text-align:left">折叠（折叠）区域 Fold (collapse) region</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+]</td>
<td style="text-align:left">展开（未折叠）区域 Unfold (uncollapse) region</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K Ctrl+[</td>
<td style="text-align:left">折叠（未折叠）所有子区域 Fold (collapse) all subregions</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K Ctrl+]</td>
<td style="text-align:left">展开（未折叠）所有子区域 Unfold (uncollapse) all subregions</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K Ctrl+0</td>
<td style="text-align:left">折叠（折叠）所有区域 Fold (collapse) all regions</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K Ctrl+J</td>
<td style="text-align:left">展开（未折叠）所有区域 Unfold (uncollapse) all regions</td>
</tr>
</tbody>
</table>
<h2 id="导航-navigation">导航 Navigation</h2>
<h2 id="搜索和替换-search-and-replace">搜索和替换 Search and replace</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl + F</td>
<td style="text-align:left">查找 Find</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + H</td>
<td style="text-align:left">替换 Replace</td>
</tr>
<tr>
<td style="text-align:left">F3 / Shift + F3</td>
<td style="text-align:left">查找下一个/上一个 Find next/previous</td>
</tr>
<tr>
<td style="text-align:left">Alt + Enter</td>
<td style="text-align:left">选择查找匹配的所有出现 Select all occurences of Find match</td>
</tr>
</tbody>
</table>
<h2 id="多光标和选择-multi-cursor-and-selection">多光标和选择 Multi-cursor and selection</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Alt +单击</td>
<td style="text-align:left">插入光标 Insert cursor</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + I</td>
<td style="text-align:left">选择当前行 Select current line</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + L</td>
<td style="text-align:left">选择当前选择的所有出现 Select all occurrences of current selection</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + F2</td>
<td style="text-align:left">选择当前字的所有出现 Select all occurrences of current word</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Shift + Alt + →</td>
<td style="text-align:left">展开选择 Expand selection</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Shift + Alt + ←</td>
<td style="text-align:left">缩小选择 Shrink selection</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="丰富的语言编辑-rich-languages-editing">丰富的语言编辑 Rich languages editing</h2>
<h2 id="编辑器管理-editor-management">编辑器管理 Editor management</h2>
<h2 id="文件管理-file-management">文件管理 File management</h2>
<h2 id="显示-display">显示 Display</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">F11</td>
<td style="text-align:left">切换全屏 Toggle full screen</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+V</td>
<td style="text-align:left">切换Markdown预览 Toggle Markdown preview</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K V</td>
<td style="text-align:left">从旁边打开Markdown预览 Open Markdown preview to the side</td>
</tr>
</tbody>
</table>
<h2 id="调试-debug">调试 Debug</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">F9</td>
<td style="text-align:left">切换断点 Toggle breakpoint</td>
</tr>
<tr>
<td style="text-align:left">F5</td>
<td style="text-align:left">开始/继续 Start/Continue</td>
</tr>
<tr>
<td style="text-align:left">Shift+F5</td>
<td style="text-align:left">停止 Stop</td>
</tr>
<tr>
<td style="text-align:left">F11 / Shift+F11</td>
<td style="text-align:left">下一步/上一步 Step into/out</td>
</tr>
<tr>
<td style="text-align:left">F10</td>
<td style="text-align:left">跳过 Step over</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K Ctrl+I</td>
<td style="text-align:left">显示悬停 Show hover</td>
</tr>
</tbody>
</table>
<h2 id="集成终端-integrated-terminal">集成终端 Integrated terminal</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl+`</td>
<td style="text-align:left">显示集成终端 Show integrated terminal</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+C</td>
<td style="text-align:left">复制选定 Copy selection</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+V</td>
<td style="text-align:left">粘贴到活动端子 Paste into active terminal</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 数据类型之 dict（讲解+案例+FAQs）]]></title>
        <id>https://numantia.github.io/post/python-dtype-dict/</id>
        <link href="https://numantia.github.io/post/python-dtype-dict/">
        </link>
        <updated>2021-06-24T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#faqs">FAQs</a>
<ul>
<li><a href="#1-%E4%B8%80%E6%AC%A1%E8%8E%B7%E5%8F%96%E5%AD%97%E5%85%B8%E5%A4%9A%E4%B8%AA%E5%80%BC">1. 一次获取字典多个值</a></li>
<li><a href="#2-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E5%AD%97%E5%85%B8">2. 函数返回值为字典</a></li>
</ul>
</li>
<li><a href="#introduction-to-dictionary">Introduction to Dictionary</a>
<ul>
<li><a href="#definition">Definition:</a></li>
<li><a href="#benifits">Benifits:</a></li>
<li><a href="#key-points">Key points:</a>
<ul>
<li><a href="#inspect">Inspect</a></li>
<li><a href="#add-a-key-overwrite-multiple-keys-update">Add a key (overwrite) /multiple keys  <strong>.update()</strong></a></li>
<li><a href="#del">Del</a></li>
<li><a href="#list-comprehensions-to-dictionaries">List Comprehensions to Dictionaries</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#using-dictionaries">Using Dictionaries</a>
<ul>
<li><a href="#key-points-2">Key points:</a>
<ul>
<li><a href="#tryexcept-to-get-a-key">Try/Except to Get a Key</a></li>
<li><a href="#safely-get-a-key-for-safe-input-get">Safely Get a Key for safe input   <strong>.get()</strong></a></li>
<li><a href="#delete-a-key-pop">Delete a key <strong>.pop( )</strong></a></li>
<li><a href="#get-all-keys-keys">Get All Keys  <strong>.keys( )</strong></a></li>
<li><a href="#get-all-values">Get all values</a></li>
<li><a href="#get-all-items">Get All Items</a></li>
</ul>
</li>
<li><a href="#project-01-scrabble">Project 01 — Scrabble</a></li>
<li><a href="#project-02-unique-values">Project 02— unique Values</a></li>
</ul>
</li>
</ul>
</p>
<p>[toc]</p>
<h1 id="faqs">FAQs</h1>
<h2 id="1-一次获取字典多个值">1. 一次获取字典多个值</h2>
<p><strong>问题描述</strong></p>
<p>无法通过 <code>.get()</code> 方法传入多个键值获得字典多个值</p>
<pre><code class="language-python">&gt;&gt;&gt; list1 = ['one', 'two', 'three']
&gt;&gt;&gt; list2 = [1, 2, 3]
&gt;&gt;&gt; mydict = dict(zip(list1,list2))
&gt;&gt;&gt; mydict.get('one')
1
&gt;&gt;&gt; mydict.get('one','two')
1
&gt;&gt;&gt; mydict['one']
1
&gt;&gt;&gt; mydict['one','two']
Traceback (most recent call last):
  File &quot;&lt;pyshell#9&gt;&quot;, line 1, in &lt;module&gt;
    mydict['one','two']
KeyError: ('one', 'two')
</code></pre>
<p><strong>解决方法1</strong> ： from operator import itemgetter</p>
<pre><code class="language-python">from operator import itemgetter
&gt;&gt;&gt; itemgetter('one','two')(mydict) # 传入键值
(1, 2)
&gt;&gt;&gt; itemgetter(*['one','two'])(mydict)# 传入字典列表，加*
(1, 2)
&gt;&gt;&gt; itemgetter(['one','two'])(mydict) # 传入字典列表，不加*
Traceback (most recent call last):
  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;
    itemgetter(['one','two'])(mydict)
TypeError: unhashable type: 'list'
</code></pre>
<p><strong>解决方法2</strong>：from pydash import at (该方法需要安装 pydash 模块)</p>
<pre><code class="language-python">from pydash import at
dict = {'a': 1, 'b': 2, 'c': 3}
list = at(dict, 'a', 'b')
list == [1, 2]
</code></pre>
<h2 id="2-函数返回值为字典">2. 函数返回值为字典</h2>
<pre><code class="language-python">def func1():
    parameters = {'a':1,'b':2,'c':3}
    return parameters
    
func1().get('a')
输出：1
</code></pre>
<h1 id="introduction-to-dictionary">Introduction to Dictionary</h1>
<h2 id="definition">Definition:</h2>
<p>A dictionary is an unordered set of key: value pairs.</p>
<pre><code class="language-python">menu = {&quot;oatmeal&quot;: 3, &quot;avocado toast&quot;: 6, &quot;carrot juice&quot;: 5, &quot;blueberry muffin&quot;: 2}
</code></pre>
<ol>
<li>A dictionary begins and ends with curly braces (<code>{</code> and <code>}</code>).</li>
<li>Each item consists of a <em>key</em> (i.e., “oatmeal”) and a value (i.e., 3)</li>
<li>Each key: value pair (i.e., <code>&quot;oatmeal&quot;: 3</code> or <code>&quot;avocado toast&quot;: 6</code>) is separated by a comma (<code>,</code>)</li>
<li>It’s considered good practice to insert a space () after each comma, but your code will still run without the space.</li>
</ol>
<p><strong>Difference between dictionary and list</strong></p>
<p><code>List</code>:  a collection of oredered objetcs</p>
<p><code>Dictionary</code>: a collection of unordered objects</p>
<h2 id="benifits">Benifits:</h2>
<ul>
<li>Use a key to get a value from a dictionary</li>
<li>Check for existence of keys</li>
<li>Find the length of a dictionary</li>
<li>Iterate through keys and values in dictionaries</li>
<li>Describe related information of an object using a bunch of key-value pair In a complex scenario</li>
<li>put many dict in a list, iterating each of elemen for the same operation</li>
</ul>
<pre><code class="language-python">card_list = [{&quot;name&quot;: &quot;张三&quot;,
              &quot;qq&quot;: &quot;12345&quot;,
              &quot;phone&quot;: &quot;110&quot;},
             {&quot;name&quot;: &quot;李四&quot;,
              &quot;qq&quot;: &quot;54321&quot;,
              &quot;phone&quot;: &quot;10086&quot;}
             ]
</code></pre>
<h2 id="key-points">Key points:</h2>
<ul>
<li>
<p>list or dictionary can not be key</p>
<p>string，number,  tuple (immutable)</p>
</li>
<li>
<p>Hash the key to determine how to store the dictionary's data in memory</p>
<ul>
<li>key : immutable data type</li>
<li>value : any type of data</li>
</ul>
</li>
</ul>
<h3 id="inspect">Inspect</h3>
<pre><code class="language-python">dict.keys()
dict.values()
dict.items()
</code></pre>
<h3 id="add-a-key-overwrite-multiple-keys-update">Add a key (overwrite) /multiple keys  <strong>.update()</strong></h3>
<pre><code class="language-python"># add a key
Dict[key] = value
if key has existed, To modify previous data
Dict.setdefault(key,value)
if key has existed, Keep the original one

animals_in_zoo={}
animals_in_zoo[&quot;zebras&quot;] = 8
animals_in_zoo[&quot;monkeys&quot;] = 12
animals_in_zoo[&quot;dinosaurs&quot;] = 0
animals_in_zoo[&quot;dinosaurs&quot;] = 2
print(animals_in_zoo)

# multiple keys
user_ids.update({&quot;theLooper&quot;:138475, &quot;stringQueen&quot;: 85739})

# overwrite
oscar_winners = {&quot;Best Picture&quot;: &quot;La La Land&quot;, &quot;Best Actor&quot;: &quot;Casey Affleck&quot;, &quot;Best Actress&quot;: &quot;Emma Stone&quot;, &quot;Animated Feature&quot;: &quot;Zootopia&quot;}
oscar_winners[&quot;Supporting Actress&quot;] = &quot;Viola Davis&quot;
oscar_winners[&quot;Best Picture&quot;] = &quot;Moonlight&quot;
</code></pre>
<h3 id="del">Del</h3>
<pre><code class="language-python">del dict[key]
dict.pop(key)  
dict.popitem()    # randomly delete
dict.clear()
</code></pre>
<h3 id="list-comprehensions-to-dictionaries">List Comprehensions to Dictionaries</h3>
<pre><code class="language-python">names = ['Jenny', 'Alexus', 'Sam', 'Grace']
heights = [61, 70, 67, 64]
students = {key:value for key, value in zip(names, heights)}
#students is now {'Jenny': 61, 'Alexus': 70, 'Sam': 67, 'Grace': 64}

Takes a pair from the zipped list of pairs from names and heights
Names the elements in the pair key (the one originally from the names list) and value (the one originally from the heights list)
Creates a key : value item in the students dictionary
Repeats steps 1-3 for the entire list of pairs
</code></pre>
<pre><code class="language-python">songs = [&quot;Like a Rolling Stone&quot;, &quot;Satisfaction&quot;, &quot;Imagine&quot;, &quot;What's Going On&quot;, &quot;Respect&quot;, &quot;Good Vibrations&quot;]
playcounts = [78, 29, 44, 21, 89, 5]
plays = {song:playcount for song, playcount in zip(songs,playcounts)}
print(plays)
plays[&quot;Purple Haze&quot;] = 1
plays[&quot;Respect&quot;] = 94

library = {&quot;The Best Songs&quot;: plays, &quot;Sunday Feelings&quot;: {}}
print(library)
</code></pre>
<h1 id="using-dictionaries">Using Dictionaries</h1>
<h2 id="key-points-2">Key points:</h2>
<h3 id="tryexcept-to-get-a-key">Try/Except to Get a Key</h3>
<pre><code class="language-python">caffeine_level = {&quot;espresso&quot;: 64, &quot;chai&quot;: 40, &quot;decaf&quot;: 0, &quot;drip&quot;: 120}

caffeine_level[&quot;matcha&quot;] = 30
key_to_check = &quot;matcha&quot;
try:
  print(caffeine_level[ key_to_check])
except KeyError:
  print(&quot;Unknown Caffeine Level&quot;)
</code></pre>
<h3 id="safely-get-a-key-for-safe-input-get">Safely Get a Key for safe input   <strong>.get()</strong></h3>
<pre><code class="language-python"># specify a value if the key doesn't exist
&gt;&gt;&gt; building_heights.get('Shanghai Tower', 0)
632
&gt;&gt;&gt; building_heights.get('Mt Olympus', 0)
0
&gt;&gt;&gt; building_heights.get('Kilimanjaro', 'No Value')
'No Value'
</code></pre>
<h3 id="delete-a-key-pop">Delete a key <strong>.pop( )</strong></h3>
<pre><code class="language-python">raffle = {223842: &quot;Teddy Bear&quot;, 872921: &quot;Concert Tickets&quot;, 320291: &quot;Gift Basket&quot;, 412123: &quot;Necklace&quot;, 298787: &quot;Pasta Maker&quot;}
raffle.pop(320291, &quot;No Prize&quot;)
&quot;Gift Basket&quot;
# 存在则返回键值，不存在则返回逗号后值
</code></pre>
<h3 id="get-all-keys-keys">Get All Keys  <strong>.keys( )</strong></h3>
<pre><code class="language-python">user_ids = {&quot;teraCoder&quot;: 100019, &quot;pythonGuy&quot;: 182921, &quot;samTheJavaMaam&quot;: 123112, &quot;lyleLoop&quot;: 102931, &quot;keysmithKeith&quot;: 129384}
num_exercises = {&quot;functions&quot;: 10, &quot;syntax&quot;: 13, &quot;control flow&quot;: 15, &quot;loops&quot;: 22, &quot;lists&quot;: 19, &quot;classes&quot;: 18, &quot;dictionaries&quot;: 18}

users = user_ids.keys()
users1 = list(user_ids)
lessons = num_exercises.keys()

print(users)
print(users1)
print(lessons)

dict_keys(['teraCoder', 'pythonGuy', 'samTheJavaMaam', 'lyleLoop', 'keysmithKeith'])
A dict_keys object is a view object, which provides a look at the current state of the dicitonary, without the user being able to modify anything.
['teraCoder', 'pythonGuy', 'samTheJavaMaam', 'lyleLoop', 'keysmithKeith']

dict_keys(['functions', 'syntax', 'control flow', 'loops', 'lists', 'classes', 'dictionaries'])
</code></pre>
<h3 id="get-all-values">Get all values</h3>
<pre><code class="language-python">num_exercises = {&quot;functions&quot;: 10, &quot;syntax&quot;: 13, &quot;control flow&quot;: 15, &quot;loops&quot;: 22, &quot;lists&quot;: 19, &quot;classes&quot;: 18, &quot;dictionaries&quot;: 18}
total_exercises = 0
for num in num_exercises.values():
  total_exercises += num
print (total_exercises)
</code></pre>
<h3 id="get-all-items">Get All Items</h3>
<pre><code class="language-python">pct_women_in_occupation = {&quot;CEO&quot;: 28, &quot;Engineering Manager&quot;: 9, &quot;Pharmacist&quot;: 58, &quot;Physician&quot;: 40, &quot;Lawyer&quot;: 37, &quot;Aerospace Engineer&quot;: 9}
for occupation, value in pct_women_in_occupation.items():
  print(&quot;Women make up &quot; +str(value) +&quot; percent of &quot;+occupation+ &quot;s.&quot;)
</code></pre>
<h2 id="project-01-scrabble">Project 01 — Scrabble</h2>
<pre><code class="language-python">letters = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;]
points = [1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 4, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10]

letter_to_points = {letter: point for letter, point in zip(letters, points)}
letter_to_points[&quot; &quot;]=0

def score_word(word):
  point_total = 0
  for letter in word:
    point_total += letter_to_points.get(letter,0)
  return point_total

brownie_points = score_word(&quot;BROWNIE&quot;)
#print(brownie_points)
player_to_words = {&quot;wordNerd&quot;: &quot;EARTH EYES MACHINE&quot;, &quot;Lexi Con&quot;: &quot;ERASER BELLY HUSKY&quot; , &quot;Prof Reader&quot;: &quot;ZAP	COMA PERIOD&quot;}
player_to_points = {}

for item in player_to_words:
  player_points = 0
  for word in player_to_words[item]:
    player_points += score_word(word)
  player_to_points[item] = player_points
print(player_to_points)
</code></pre>
<h2 id="project-02-unique-values">Project 02— unique Values</h2>
<pre><code class="language-python">oscars = {&quot;Best Picture&quot;: &quot;Moonlight&quot;, &quot;Best Actor&quot;: &quot;Casey Affleck&quot;, &quot;Best Actress&quot;: &quot;Emma Stone&quot;, &quot;Animated Feature&quot;: &quot;Zootopia&quot;}

for element in oscars:
  print(element)

# Unique Values
def unique_values (my_dictionary):
  num_value = 0
  before_letter = []
  for value in my_dictionary.values():
    if not value in  before_letter:
      num_value += 1
    before_letter.append(value)
  return num_value
# Uncomment these function calls to test your  function:
# print(unique_values({0:3, 1:1, 4:1, 5:3}))
# should print 2
# print(unique_values({0:3, 1:3, 4:3, 5:3}))
# should print 1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 装饰器用法]]></title>
        <id>https://numantia.github.io/post/python-advanced-decorator/</id>
        <link href="https://numantia.github.io/post/python-advanced-decorator/">
        </link>
        <updated>2021-06-23T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8">为什么要用装饰器</a></li>
<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">装饰器机制分析</a></li>
<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%85%A5%E9%97%A8">装饰器入门</a>
<ul>
<li><a href="#1-%E5%AF%B9%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%A3%85%E9%A5%B0">1. 对带参数的函数进行装饰</a></li>
<li><a href="#2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E4%B8%8D%E7%A1%AE%E5%AE%9A">2. 函数参数数量不确定</a></li>
<li><a href="#3-%E8%A3%85%E9%A5%B0%E5%99%A8%E5%B8%A6%E5%8F%82%E6%95%B0">3. 装饰器带参数</a></li>
<li><a href="#4-functoolswraps-%E8%BF%98%E5%8E%9F%E5%87%BD%E6%95%B0%E5%8E%9F%E4%BF%A1%E6%81%AF">4. functools.wraps - 还原函数原信息</a></li>
<li><a href="#5-%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%8F%82%E6%95%B0%E5%92%8C%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E8%87%AA%E9%80%82%E5%BA%94">5. 实现带参数和不带参数的装饰器自适应</a></li>
<li><a href="#6-%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8">6. 类装饰器</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">装饰器应用场景</a>
<ul>
<li><a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81">用户验证</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E5%90%88%E7%90%86%E6%80%A7%E6%A3%80%E6%9F%A5">输入合理性检查</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E5%8C%96">输出格式化</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7">异常捕获</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86">日志管理</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E8%A3%85%E9%A5%B0%E5%99%A8">缓存装饰器</a></li>
</ul>
</li>
</ul>
</p>
<p>[toc]</p>
<pre><code class="language-python">@dec
def func():
    pass
</code></pre>
<p>装饰器（Decorator）为装饰对象的器件，既可以装饰[函数](# 1. 对带参数的函数进行装饰)，又可以装饰[类](# 6. 类装饰器)。可以在不修改代码条件下，为装饰对象添加新的功能或者帮助输出。装饰器的典型应用场景有<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>、<a href="#%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81">用户验证</a>、<a href="#%E8%BE%93%E5%85%A5%E5%90%88%E7%90%86%E6%80%A7%E6%A3%80%E6%9F%A5">输入合理性检查</a>、<a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E5%8C%96">输出格式化</a>、<a href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7">异常捕获</a>、<a href="#%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86">日志管理</a>。</p>
<h1 id="为什么要用装饰器">为什么要用装饰器</h1>
<p>在<a href="https://github.com/micheles/decorator/blob/master/docs/documentation.md">官方文档</a>中，Python 2.4 引入的<code>decorators</code> , 具有重要优势：</p>
<blockquote>
<ul>
<li>decorators help reducing boilerplate code;  减少样板代码</li>
<li>decorators help separation of concerns;  分离关注点</li>
<li>decorators enhance readability and maintenability; 增强可读性和可维护性</li>
<li>decorators are explicit. 显示的装饰器</li>
</ul>
</blockquote>
<ol>
<li>
<p><a href="mailto:michele.simionato@gmail.com"> michele.simionato</a> 开发的 <code>decorator</code> 模块，简化了<code>decorators</code>的使用，并附上了许多经典案例。</p>
</li>
<li>
<p><a href="https://www.cnblogs.com/arvin-feng/p/11108799.html">Python 装饰器用法实例总结</a>第二节有简单的例子，解释符合开放封闭原则，降低多函数重复代码量和频繁改动，将非核心的日志记录功能和函数分离开，有利于保证核心业务代码的简洁和易理解性。</p>
</li>
<li>
<p><a href="https://www.liujiangblog.com/course/python/39">Python 装饰器</a> 中经过用户验证场景不同解决方案的更迭来说明装饰器的优势。</p>
</li>
</ol>
<blockquote>
<p>使用装饰器@outer，也是仅需对基础平台的代码进行拓展，就可以实现在其他部门调用函数 API 之前都进行认证操作，在操作结束后保存日志，并且其他业务部门无需对他们自己的代码做任何修改，调用方式也不用变。</p>
</blockquote>
<h1 id="装饰器机制分析">装饰器机制分析</h1>
<p>本节摘自<a href="https://www.liujiangblog.com/course/python/39">Python 装饰器</a> ，在其基础上补充更为直观的图示和流程图说明，文字描述可以详细查看原文章。</p>
<pre><code class="language-python">def outer(func):
    def inner():
        print(&quot;认证成功！&quot;)
        result = func()
        print(&quot;日志添加成功&quot;)
        return result
    return inner

@outer
def f1():
    print(&quot;业务部门1数据接口......&quot;)

r = f1()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://numantia.github.io/post-images/decorator-mechanism.png" alt="decorator-mechanism" loading="lazy"></figure>
<p>​													                装饰器工作机制</p>
<figure data-type="image" tabindex="2"><img src="https://numantia.github.io/post-images/decorator-mechanism2.png" alt="decorator-mechanism2" loading="lazy"></figure>
<p>​															装饰器工作流程图</p>
<pre><code class="language-python"># 验证 inner 函数返回给 f1，即 f1 对象内存指向 inner内存

def outer(func):
    print(&quot;传入实参内存地址：%d&quot; %id(func))
    def inner():
        print(&quot;认证成功！&quot;)
        result = func()
        print(&quot;日志添加成功&quot;)
        return result
    print(&quot;Outer 内部函数 inner 内存地址：%d&quot; %id(inner))
    return inner

@outer
def f1():
    print(&quot;业务部门1数据接口......&quot;)

print(&quot;装饰后 f1 函数内存地址：%d&quot; %id(f1))
r = f1()

&gt;&gt;&gt; 输出结果
传入实参内存地址：32354376
Outer 内部函数 inner 内存地址：32372632
装饰后 f1 函数内存地址：32372632
认证成功！
业务部门1数据接口......
日志添加成功
</code></pre>
<h1 id="装饰器入门">装饰器入门</h1>
<p>本节摘自<a href="https://www.cnblogs.com/arvin-feng/p/11108799.html">Python装饰器用法实例总结</a></p>
<h2 id="1-对带参数的函数进行装饰">1. 对带参数的函数进行装饰</h2>
<p>内层函数进行改动传入我们的两个参数a和b，等价于use_logging(bar)(1,2)</p>
<pre><code class="language-python">def use_logging(func):
  def _deco(a,b):
    print(&quot;%s is running&quot; % func.__name__)
    func(a,b)
  return _deco
@use_logging
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,2)
</code></pre>
<h2 id="2-函数参数数量不确定">2. 函数参数数量不确定</h2>
<p>使用python的变长参数 *args和**kwargs 解决不定参数问题</p>
<pre><code class="language-python">def use_logging(func):
  def _deco(*args,**kwargs):
    print(&quot;%s is running&quot; % func.__name__)
    func(*args,**kwargs)
  return _deco
@use_logging
def bar(a,b):
  print('i am bar:%s'%(a+b))
@use_logging
def foo(a,b,c):
  print('i am bar:%s'%(a+b+c))
bar(1,2)
foo(1,2,3)
</code></pre>
<h2 id="3-装饰器带参数">3. 装饰器带参数</h2>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
def use_logging(level):
  def _deco(func):
    def __deco(*args, **kwargs):
      if level == &quot;warn&quot;:
        print &quot;%s is running&quot; % func.__name__
      return func(*args, **kwargs)
    return __deco
  return _deco
@use_logging(level=&quot;warn&quot;)
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,3)
# 等价于use_logging(level=&quot;warn&quot;)(bar)(1,3)
</code></pre>
<h2 id="4-functoolswraps-还原函数原信息">4. functools.wraps - 还原函数原信息</h2>
<p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、<strong>name</strong>、参数列表</p>
<pre><code class="language-python">def use_logging(func):
  def _deco(*args,**kwargs):
    print(&quot;%s is running&quot; % func.__name__)
    func(*args,**kwargs)
  return _deco
@use_logging
def bar():
  print('i am bar')
  print(bar.__name__)
bar()
#bar is running
#i am bar
#_deco
#函数名变为_deco而不是bar，这个情况在使用反射的特性的时候就会造成问题。因此引入了functools.wraps解决这个问题。
</code></pre>
<pre><code class="language-python"># 使用functools.wraps:
import functools
def use_logging(func):
  @functools.wraps(func)
  def _deco(*args,**kwargs):
    print(&quot;%s is running&quot; % func.__name__)
    func(*args,**kwargs)
  return _deco
@use_logging
def bar():
  print('i am bar')
  print(bar.__name__)
bar()
#result:
#bar is running
#i am bar
#bar ,这个结果是我们想要的。OK啦！
</code></pre>
<h2 id="5-实现带参数和不带参数的装饰器自适应">5. 实现带参数和不带参数的装饰器自适应</h2>
<pre><code class="language-python">import functools
def use_logging(arg):
  if callable(arg):#判断参入的参数是否是函数，不带参数的装饰器调用这个分支
    @functools.wraps(arg)
    def _deco(*args,**kwargs):
      print(&quot;%s is running&quot; % arg.__name__)
      arg(*args,**kwargs)
    return _deco
  else:#带参数的装饰器调用这个分支
    def _deco(func):
      @functools.wraps(func)
      def __deco(*args, **kwargs):
        if arg == &quot;warn&quot;:
          print &quot;warn%s is running&quot; % func.__name__
        return func(*args, **kwargs)
      return __deco
    return _deco
@use_logging(&quot;warn&quot;)
# @use_logging
def bar():
  print('i am bar')
  print(bar.__name__)
bar()
</code></pre>
<h2 id="6-类装饰器">6. 类装饰器</h2>
<p>使用类装饰器可以实现带参数装饰器的效果，但实现的更加优雅简洁,而且可以通过继承来灵活的扩展.</p>
<pre><code class="language-python">class loging(object):
  def __init__(self,level=&quot;warn&quot;):
    self.level = level
  def __call__(self,func):
    @functools.wraps(func)
    def _deco(*args, **kwargs):
      if self.level == &quot;warn&quot;:
        self.notify(func)
      return func(*args, **kwargs)
    return _deco
  def notify(self,func):
    # logit只打日志，不做别的
    print &quot;%s is running&quot; % func.__name__
@loging(level=&quot;warn&quot;)  #执行__call__方法
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,3)
</code></pre>
<p><strong>继承扩展类装饰器</strong></p>
<pre><code class="language-python">class email_loging(Loging):
  '''
  	一个loging的实现版本，可以在函数调用时发送email给管理员
  	__init__ ：不再接收被装饰函数，而是接收传入参数。
	__call__ ：接收被装饰函数，实现装饰逻辑。
  '''
  def __init__(self, email='admin@myproject.com', *args, **kwargs):
    self.email = email
    super(email_loging, self).__init__(*args, **kwargs)
  def notify(self,func):
    # 发送一封email到self.email
    print &quot;%s is running&quot; % func.__name__
    print &quot;sending email to %s&quot; %self.email
@email_loging(level=&quot;warn&quot;)
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,3)
arvin_feng
</code></pre>
<h1 id="装饰器应用场景">装饰器应用场景</h1>
<p>该节摘抄记录自文章<a href="http://c.biancheng.net/view/5410.html">Python装饰器的应用场景</a>，文章<a href="https://www.cnblogs.com/superhin/p/11454823.html">Python装饰器的应用场景</a></p>
<h2 id="类型检查">类型检查</h2>
<pre><code class="language-python">from functools import wraps
def require_ints(func):
  @wraps(func) # 将func的信息复制给inner
  def inner(*args, **kwargs):
    for arg list(args) + list(kwargs.values()):
      if not isinstance(arg, int:
        raise TypeError(&quot;{} 只接受int类型参数&quot;.format(func.__name__)
    return func(*args, **kwargs)
  return inner
</code></pre>
<h2 id="用户验证">用户验证</h2>
<p>定义了装饰器 authenticate，函数 post_comment() 则表示发表用户对某篇文章的评论，每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。</p>
<pre><code class="language-python">import functools

def authenticate(func):
    @functools.wraps(func)
    # @functools.wraps(func) 也是一个装饰器，
    # 不使用它，则 post_comment.__name__ 的值为 wrapper。
    # 使用它之后，则 post_comment.__name__ 的值依然为 post_comment。
    def wrapper(*args, **kwargs):
        request = args[0]
        # 如果用户处于登录状态
        if check_user_logged_in(request):
            # 执行函数 post_comment()
            return func(*args, **kwargs)  
        else:
            raise Exception('Authentication failed')
    return wrapper
   
@authenticate
def post_comment(request, ...)
    ...
</code></pre>
<h2 id="输入合理性检查">输入合理性检查</h2>
<p>在大型公司的机器学习框架中，调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检查。这样就可以</p>
<ol>
<li>大大避免输入不正确对机器造成的巨大开销。其实在工作中，很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现。</li>
<li>如果没有输入的合理性检查，很容易出现“模型训练了好几个小时后，系统却报错说输入的一个参数不对，成果付之一炬”的现象。这样的“惨案”，大大减缓了开发效率，也对机器资源造成了巨大浪费。</li>
</ol>
<pre><code class="language-python">import functools

def validation_check(input):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        ... # 检查输入是否合法
   
@validation_check
def neural_network_training(param1, param2, ...):
    ...
</code></pre>
<h2 id="输出格式化">输出格式化</h2>
<pre><code class="language-python">import json
from functools import wraps

def json_output(func):  # 将原本func返回的字典格式转为返回json字符串格式
    @wrap(func)
    def inner(*args, **kwargs):
        return json.dumps(func(*args, **kwargs))
    return inner
</code></pre>
<h2 id="异常捕获">异常捕获</h2>
<pre><code class="language-python">import json
from functools import wraps

class Error1(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return self.msg
        

def json_output(func):
    @wrap(func)
    def inner(*args, **kwargs):
        try:
            result = func(*args, **kwargs)
        except Error1 as ex:
            result = {&quot;status&quot;: &quot;error&quot;, &quot;msg&quot;: str(ex)}
        return json.dumps(result)
    return inner

# 使用方法
@json_ouput
def error():
    raise Error1(&quot;该条异常会被捕获并按JSON格式输出&quot;)
</code></pre>
<h2 id="日志管理">日志管理</h2>
<p>测试函数耗时，装饰器方式秉持开放封闭原则，无需调增函数体内部，而是通过外部封装方式，减少耦合。</p>
<pre><code class="language-python">import time
import logging
from functools import wraps

def logged(func):
    @wraps(func)
    def inner(*args, **kwargs):  # *args可以装饰函数也可以装饰类
        start = time.time()
        result = func(*args, **kwargs)
        exec_time = time.time() - start
        logger = logging.getLoger(&quot;func.logged&quot;)
        logger.warning(&quot;{} 调用时间:{:.2} 执行时间:{:.2}s 结果:{}&quot;.format(func.__name__, start, exec_time, result)

def calculate_similarity(items):
    ...
</code></pre>
<h2 id="缓存装饰器">缓存装饰器</h2>
<p>关于缓存装饰器的用法，其实十分常见，这里以 <a href="http://c.biancheng.net/python/">Python</a> 内置的 LRU cache 为例来说明。LRU cache，在 Python 中的表示形式是 @lru_cache。@lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除最近最久未使用的数据。</p>
<p>正确使用缓存装饰器，往往能极大地提高程序运行效率。举个例子，大型公司服务器端的代码中往往存在很多关于设备的检查，比如使用的设备是安卓还是 iPhone，版本号是多少。这其中的一个原因，就是一些新的功能，往往只在某些特定的手机系统或版本上才有。这样一来，我们通常使用缓存装饰器来包裹这些检查函数，避免其被反复调用，进而提高程序运行效率，比如写成下面这样：</p>
<pre><code class="language-python">@lru_cache
def check(param1, param2, ...) # 检查用户设备类型，版本号等等
    ...
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 数据类型之 list（讲解+案例+FAQs）]]></title>
        <id>https://numantia.github.io/post/python-dtype-list/</id>
        <link href="https://numantia.github.io/post/python-dtype-list/">
        </link>
        <updated>2021-06-18T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<p><ul class="markdownIt-TOC">
<li><a href="#faqs">FAQs</a>
<ul>
<li><a href="#1-list-comprehension-%E5%8F%8C%E5%BE%AA%E7%8E%AF">1. List Comprehension - 双循环</a></li>
<li><a href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">2. 初始化一维数组+二维数组</a></li>
<li><a href="#3-typeerror-list-indices-must-be-integers-or-slices-not-tuple">3. TypeError: list indices must be integers or slices, not tuple</a></li>
<li><a href="#4-indexerror-list-assignment-index-out-of-range">4. IndexError: list assignment index out of range</a></li>
<li><a href="#5-typeerror-list-object-is-not-callable">5. TypeError: 'list' object is not callable</a></li>
<li><a href="#6-python-%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E9%87%8C%E5%85%83%E7%B4%A0%E5%AF%B9%E5%BA%94%E7%9B%B8%E4%B9%98">6. Python 实现两个列表里元素对应相乘</a></li>
<li><a href="#7-list-%E5%88%A4%E6%96%AD%E7%A9%BA%E4%B8%8E%E9%9D%9E%E7%A9%BA">7. List 判断空与非空</a></li>
<li><a href="#8-listappend-%E8%BE%93%E5%87%BA%E4%B8%BAnone">8. List.append() 输出为None</a></li>
<li><a href="#9-list-%E5%90%88%E5%B9%B6%E5%88%A4%E6%96%AD%E5%88%97%E8%A1%A8%E4%B8%BA%E7%BB%B4%E6%95%B0">9. List 合并，判断列表为维数</a></li>
<li><a href="#10-float-%E5%9E%8B%E5%88%97%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%B8%BA-int-%E5%9E%8B%E5%88%97%E8%A1%A8">10. Float 型列表转化为 Int 型列表</a></li>
</ul>
</li>
<li><a href="#creating-a-list-in-python">Creating a List in Python</a>
<ul>
<li><a href="#definition">Definition:</a></li>
<li><a href="#benifits">Benifits:</a></li>
<li><a href="#key-points">Key points:</a>
<ul>
<li><a href="#ziplist1list2">zip(list1,list2)</a></li>
<li><a href="#list-modifying-operation">List modifying operation</a></li>
<li><a href="#range">Range()</a></li>
<li><a href="#project-01gradebook">Project 01—Gradebook</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#modifying-python-lists">Modifying python lists</a>
<ul>
<li><a href="#definition-2">Definition:</a></li>
<li><a href="#benifits-2">Benifits:</a></li>
<li><a href="#key-points-2">Key points:</a>
<ul>
<li><a href="#get-the-length-of-a-list-len">Get the length of a list <strong>len()</strong></a></li>
<li><a href="#select-subsets-of-a-list-called-slicing-1">Select subsets of a list (called <em><strong>slicing</strong></em>)  [ ] [-1] [:]</a></li>
<li><a href="#count-the-number-of-times-that-an-element-appears-in-a-list-letterscounti">Count the number of times that an element appears in a list <strong>letters.count('i')</strong></a></li>
<li><a href="#sort-a-list-of-items-sort-sorted">Sort a list of items ****.sort()   sorted(<strong>)</strong></a></li>
<li><a href="#project-01-lens-slice">Project 01 — Len's Slice</a></li>
<li><a href="#project-02-list-aggregate">Project 02 —List Aggregate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#summary">Summary</a>
<ul>
<li><a href="#add"><strong>ADD</strong></a></li>
<li><a href="#modify"><strong>MODIFY</strong></a></li>
<li><a href="#del"><strong>DEL</strong></a></li>
<li><a href="#aggeregate-function"><strong>Aggeregate function</strong></a></li>
<li><a href="#sort"><strong>Sort</strong></a></li>
</ul>
</li>
</ul>
</p>
<h1 id="faqs">FAQs</h1>
<h2 id="1-list-comprehension-双循环">1. List Comprehension - 双循环</h2>
<pre><code class="language-python">ntest=['a','b']
ltest=[[1,2],[4,5,6]]
data=[(k,v) for k,l in zip(ntest,ltest) for v in l] 
</code></pre>
<p>https://blog.csdn.net/leavemetomorrow/article/details/90641362</p>
<h2 id="2-初始化一维数组二维数组">2. 初始化一维数组+二维数组</h2>
<pre><code class="language-python"># 一维数组
a = [None] * n # 方法1
a = [None for i in range(n)] # 方法2

&gt;&gt;&gt; [None, None, None, None, None]

# 二维数组
a = [list()] * 5 # 浅拷贝方法，所有List会同步变化
a[0].append(1)  # 方法1
&gt;&gt;&gt; [[1], [1], [1], [1], [1]]

a = [list() for i in range(5)] # 所有List独立
a[0].append(1)  # 方法2
&gt;&gt;&gt; [[1], [], [], [], []]
</code></pre>
<h2 id="3-typeerror-list-indices-must-be-integers-or-slices-not-tuple">3. TypeError: list indices must be integers or slices, not tuple</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; a=[[1,2,3],[4,5,6]]
&gt;&gt;&gt; a[0]    #取一行
[1, 2, 3]
&gt;&gt;&gt; a[:,0]  #尝试用数组的方法读取一列失败
TypeError: list indices must be integers or slices, not tuple
</code></pre>
<p><strong>产生原因</strong></p>
<p>列表存储不同类型数据，列表元素大小相同或者不同，不支持读取一列</p>
<p><strong>解决方法1</strong>：列表解析的方法</p>
<pre><code class="language-python">&gt;&gt;&gt; b=[x[0] for x in a]
&gt;&gt;&gt; print(b)
</code></pre>
<p><strong>解决方法2</strong>:  转化为数组直接读取</p>
<pre><code class="language-python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a=np.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; a[:,0]
array([1, 4])
</code></pre>
<h2 id="4-indexerror-list-assignment-index-out-of-range">4. IndexError: list assignment index out of range</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-python">m1=[]
for i in range(10):
	m1[i]=1
</code></pre>
<p><strong>产生原因</strong></p>
<p>空数组无法直接确定位置，因为内存中尚未分配</p>
<p>**解决方法1：**使用append方法</p>
<pre><code class="language-python">m1.append(1）
</code></pre>
<p>**解决方法2：**先生成一个定长的list</p>
<pre><code class="language-python">m1=[0]*len(data)
m1[1]=1
</code></pre>
<h2 id="5-typeerror-list-object-is-not-callable">5. TypeError: 'list' object is not callable</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-powershell">&gt;&gt;&gt; str = &quot;ABCDEF&quot;
&gt;&gt;&gt; list = [1, 2 ,3 ,4 ,5,6 ]
&gt;&gt;&gt; list(str)

TypeError: 'list' object is not callable
</code></pre>
<p><strong>产生原因</strong></p>
<p>callable() 是python 的内置函数，用来检查对象是否可被调用</p>
<p>变量list和函数list重名，所以函数在使用list函数时，发现list是一个定义好的列表，而列表是不能把被调用的，因此抛出一个类型错误</p>
<h2 id="6-python-实现两个列表里元素对应相乘">6. Python 实现两个列表里元素对应相乘</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-powershell">&gt;&gt;&gt; list1 = [1,2,3]
&gt;&gt;&gt; list2 = [4,5,6]
&gt;&gt;&gt; list1*list2

TypeError: can't multiply sequence by non-int of type 'list'
</code></pre>
<p><strong>解决方法1 ： Map函数</strong></p>
<pre><code class="language-python">List1 = [1,2,3,4]
List2 = [5,6,7,8]
List3 = map(lambda a,b:a*b,zip(List1,List2))
print List3
</code></pre>
<p><strong>解决方法2: np.multiply</strong></p>
<pre><code class="language-python">List1 = [1,2,3]
List2 = [5,6,7]
List3 = np.multiply(np.array(List1),np.array(List2))
print List3.tolist()
</code></pre>
<h2 id="7-list-判断空与非空">7. List 判断空与非空</h2>
<pre><code class="language-python"># 一、二维通用
list = []
if list:
    print('非空')
if not list:
    print('空')
</code></pre>
<h2 id="8-listappend-输出为none">8. List.append() 输出为None</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; a = []
&gt;&gt;&gt; a =  a.append(1)
&gt;&gt;&gt; print(a)
None
</code></pre>
<p><strong>产生原因</strong></p>
<p>append 方法不是返回一个列表，而只是修改原来的列表，所以如果用 <strong>等式</strong> 输出的话，返回是<code>None</code></p>
<p><strong>解决方法</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; a = []
&gt;&gt;&gt; a.append(1)
&gt;&gt;&gt; print(a)
1
</code></pre>
<h2 id="9-list-合并判断列表为维数">9. List 合并，判断列表为维数</h2>
<pre><code class="language-python"># 两个列表交叉合并
a=[1,2,3,4,5]
b=[2,3,4,5,6]
c=[]
for x,y in zip(a,b):
    c.append([x,y])
print(c)

result ： [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]

# 二维列表的合并
a=[1,2,3,4,5]
b=[2,3,4,5,6]
c = [a,b]
d = []
for x,y in zip(*c):
    d.append([x,y])
print(d)

result ： [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]

# 
import numpy as np
a=[0.1,0.2, 0.1, 0.1, 0.1, 0.1]
b=[[0.1, 0.1], [0.2, 0.1], [0.1, 0.1]]
c=[[[0.1,0.5], [0.1,0.8]]]

L1=np.array(a)
print(L1.shape)
print(len(L1.shape))
L=np.array(b)
print(L.shape)
print(len(L.shape))
L2=np.array(c)
print(L2.shape)
print(len(L2.shape))

result :
(6,)
1 # 1维
(3, 2)
2 # 2维
(1, 2, 2)
3 # 3维
</code></pre>
<h2 id="10-float-型列表转化为-int-型列表">10. Float 型列表转化为 Int 型列表</h2>
<p><strong>方法1:</strong> 使用map方法</p>
<pre><code class="language-python">&gt;&gt;&gt; list = [1.3, 2.3, 4, 5]　　　#带有float型的列表　
&gt;&gt;&gt; int_list = map(int,list)　　#使用map转换
&gt;&gt;&gt; print int_list　　　　　　　　
[1, 2, 4, 5]
</code></pre>
<p>**方法2：**使用for循环</p>
<pre><code class="language-python">list1 =  [1.3,2.3,4,5]
lista = []
for i in list1:
     i =int(i)
     lista.append(i)
print lista

[1, 2, 4, 5]
</code></pre>
<blockquote>
<p>参考<a href="https://www.cnblogs.com/xuchunlin/p/6305709.html">文章</a></p>
</blockquote>
<h1 id="creating-a-list-in-python">Creating a List in Python</h1>
<h2 id="definition">Definition:</h2>
<p><em>A list is an ordered set of objects in Python, combine multiple data types in one list.</em></p>
<h2 id="benifits">Benifits:</h2>
<h2 id="key-points">Key points:</h2>
<ul>
<li>heights = [61,<mark>space</mark> 70, 67, 64]  # To insert space between two element is recommended</li>
</ul>
<h3 id="ziplist1list2">zip(list1,list2)</h3>
<p>takes two (or more) lists as inputs and returns an object that contains a list of pairs.</p>
<pre><code class="language-python">names_and_heights = zip(names, heights)
print(names_and_heights)
because it will return the location of this object in memory. Output would look something like this:

&lt;zip object at 0x7f1631e86b48&gt;

To see the nested lists, you can convert the zip object to a list first:

print(list(names_and_heights))
returns:

[('Jenny', 61), ('Alexus', 70), ('Sam', 67), ('Grace', 65)]
</code></pre>
<h3 id="list-modifying-operation">List modifying operation</h3>
<pre><code class="language-python">#  add one item to a list
***.append()
def append_sum(lst):
  lst.append(lst[-1] + lst[-2])
  lst.append(lst[-1] + lst[-2])
  lst.append(lst[-1] + lst[-2])
  return lst
# Add multiple items to a list
+
gradebook + [(&quot;visual arts&quot;, 93)]
</code></pre>
<h3 id="range">Range()</h3>
<pre><code class="language-python">my_range = range(10)
&gt;&gt;&gt; print(my_range)
range(0, 10)

&gt;&gt;&gt; print(list(my_range))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

my_range3 = range(1, 100, 10)
before 100 在100之间不包括100
</code></pre>
<h3 id="project-01gradebook">Project 01—Gradebook</h3>
<pre><code class="language-python">last_semester_gradebook = [(&quot;politics&quot;, 80), (&quot;latin&quot;, 96), (&quot;dance&quot;, 97), (&quot;architecture&quot;, 65)]
subjects = [&quot;physics&quot;, &quot;calculus&quot;, &quot;poetry&quot;, &quot;history&quot;]
grades = [98, 97, 85, 88]
subjects.append(&quot;computer science&quot;)
grades.append(100)
gradebook=list(zip(subjects, grades))
gradebook + [(&quot;visual arts&quot;, 93)]
full_gradebook = gradebook + last_semester_gradebook
print (full_gradebook)
</code></pre>
<h1 id="modifying-python-lists">Modifying python lists</h1>
<h2 id="definition-2">Definition:</h2>
<p><em>How to work with existing lists of data</em></p>
<h2 id="benifits-2">Benifits:</h2>
<h2 id="key-points-2">Key points:</h2>
<h3 id="get-the-length-of-a-list-len">Get the length of a list <strong>len()</strong></h3>
<h3 id="select-subsets-of-a-list-called-slicing-1">Select subsets of a list (called <em><strong>slicing</strong></em>)  [ ] [-1] [:]</h3>
<pre><code class="language-python">shopping_list = ['eggs', 'butter', 'milk', 'cucumbers', 'juice', 'cereal']
print(shopping_list[len(shopping_list)-1])
# the last term of list
print(shopping_list[-1])
# 6 not included in the list 
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
sublist = letters[1:6]
print(sublist)

['b', 'c', 'd', 'e', 'f']

suitcase = ['shirt', 'shirt', 'pants', 'pants', 'pajamas', 'books']
start = suitcase[:3]
end = suitcase[-2:]
</code></pre>
<h3 id="count-the-number-of-times-that-an-element-appears-in-a-list-letterscounti">Count the number of times that an element appears in a list <strong>letters.count('i')</strong></h3>
<h3 id="sort-a-list-of-items-sort-sorted">Sort a list of items ****.sort()   sorted(<strong>)</strong></h3>
<pre><code class="language-python"># sort and sorted have different usuage

# Sort return &quot;none&quot;,after sort(),list will change itself
sorted_names = names.sort()
print(sorted_names)

lst.sort()
return lst

# sorted return sorted_list and have no change to original list
sorted_names = sorted(names)
</code></pre>
<h3 id="project-01-lens-slice">Project 01 — Len's Slice</h3>
<pre><code class="language-python">toppings =['pepperoni', 'pineapple', 'cheese', 'sausage', 'olives','anchovies', 'mushrooms', ]
prices= [2,6,1,3,2,7,2]
num_pizzas = len(toppings)
print (&quot;We sell &quot;+ str(num_pizzas) + &quot; different kinds of pizza!&quot;)

pizzas = list(zip(prices, toppings))

pizzas.sort()
print (pizzas)
cheapest_pizza = pizzas[0]
priciest_pizza = pizzas[-1]
print (&quot;I will have your MOST EXPENSIVE pizza!&quot;)
three_cheapest = pizzas[:3]
print(three_cheapest)

num_two_dollar_slices=prices.count(2)
print (num_two_dollar_slices)
</code></pre>
<h3 id="project-02-list-aggregate">Project 02 —List Aggregate</h3>
<pre><code class="language-python"># Double index
def double_index(lst,index):
  if index &lt;= len(lst)-1:
    lst[index]=lst[index]*2
    return lst
  else:
    return lst
  
print(double_index([3, 8, -10, 12], 2))
# Remove middle
def remove_middle(lst, start, end): 
  lst=lst[:start]+lst[end+1:]
  return lst

print(remove_middle([4, 8, 15, 16, 23, 42], 1, 3))

#More than N
def more_than_n (lst, item, n):
  if lst.count(item)&gt;n:
    return True
  else:
    return False

print(more_than_n([2, 4, 6, 2, 3, 2, 1, 2], 2, 3))

# More Frequent Item
def more_frequent_item (lst,item1,item2):
  if lst.count(item1) &gt;= lst.count(item2):
    return item1
  else:
    return item2
print(more_frequent_item([2, 3, 3, 2, 3, 2, 3, 2, 3], 2, 3))

# Middle Item
def middle_element(lst):
  if len(lst) % 2 == 0:
    sum = lst[int(len(lst)/2)] + lst[int(len(lst)/2) - 1]
    return sum / 2
  else:
    return lst[int(len(lst)/2)]

print(middle_element([5, 2, -10, -4, 4, 5]))
</code></pre>
<h1 id="summary">Summary</h1>
<h2 id="add"><strong>ADD</strong></h2>
<p>list.append(data)</p>
<p>list1.extend(list2)</p>
<p>liat1.insert(index,data)</p>
<h2 id="modify"><strong>MODIFY</strong></h2>
<p>list[index] = data</p>
<h2 id="del"><strong>DEL</strong></h2>
<p>del list[index]     # unrecommended</p>
<p>list.remove[data]  Delete specified element of first appearance in the list</p>
<p>list.pop()    delete the final one element</p>
<p>list.pop(index)  delete element at specific location</p>
<p>list.clear  delete the whole of list</p>
<h2 id="aggeregate-function"><strong>Aggeregate function</strong></h2>
<p>list.count(data)</p>
<p>len(list)</p>
<h2 id="sort"><strong>Sort</strong></h2>
<p>list.sort(reverse = true)    descending sort</p>
<p>list.reverse()    reverse the order</p>
<p>sorted()</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python print() 常见用法]]></title>
        <id>https://numantia.github.io/post/python-print/</id>
        <link href="https://numantia.github.io/post/python-print/">
        </link>
        <updated>2021-06-16T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
</code></pre>
<ul>
<li>objects -- 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。</li>
<li>sep -- 用来间隔多个对象，默认值是一个空格。</li>
<li>end -- 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。</li>
<li>file -- 要写入的文件对象。</li>
<li>flush -- 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新</li>
</ul>
<p><strong>例子1：输出字符串</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; print(&quot;aaa&quot;&quot;bbb&quot;)
aaabbb
&gt;&gt;&gt; print(&quot;aaa&quot;,&quot;bbb&quot;)
aaa bbb
&gt;&gt;&gt; 
 
&gt;&gt;&gt; print(&quot;www&quot;,&quot;runoob&quot;,&quot;com&quot;,sep=&quot;.&quot;)  # 设置间隔符
www.runoob.com
</code></pre>
<p><strong>例子2：实现 Loading 效果</strong></p>
<pre><code class="language-python">import time

print(&quot;Loading&quot;,end = &quot;&quot;) # 结尾不换行
for i in range(20):
    print(&quot;.&quot;,end = '',flush = True) #结尾不换行，缓存输出
    time.sleep(0.5)

#运行结果
Loading......
</code></pre>
<p><strong>例子3：Python format 格式化函数<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></strong></p>
<pre><code class="language-python">&gt;&gt;&gt;&quot;{} {}&quot;.format(&quot;hello&quot;, &quot;world&quot;)    # 不设置指定位置，按默认顺序
'hello world'
 
&gt;&gt;&gt; &quot;{0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;)  # 设置指定位置
'hello world'
 
&gt;&gt;&gt; &quot;{1} {0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;)  # 设置指定位置
'world hello world'
</code></pre>
<pre><code class="language-python"># 设置参数
print(&quot;网站名：{name}, 地址 {url}&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;))
 
# 通过字典设置参数
site = {&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;}
print(&quot;网站名：{name}, 地址 {url}&quot;.format(site))
 
# 通过列表索引设置参数
my_list = ['菜鸟教程', 'www.runoob.com']
print(&quot;网站名：{0[0]}, 地址 {0[1]}&quot;.format(my_list))  # &quot;0&quot; 是必须的
</code></pre>
<p><strong>例子4：.format() 格式化输出</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; print(&quot;{:.2f}&quot;.format(3.1415926))
3.14
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">数字</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">输出</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">3.1415926</td>
<td style="text-align:left">{:.2f}</td>
<td style="text-align:left">3.14</td>
<td style="text-align:left">保留小数点后两位</td>
</tr>
<tr>
<td style="text-align:left">3.1415926</td>
<td style="text-align:left">{:+.2f}</td>
<td style="text-align:left">+3.14</td>
<td style="text-align:left">带符号保留小数点后两位</td>
</tr>
<tr>
<td style="text-align:left">-1</td>
<td style="text-align:left">{:+.2f}</td>
<td style="text-align:left">-1.00</td>
<td style="text-align:left">带符号保留小数点后两位</td>
</tr>
<tr>
<td style="text-align:left">2.71828</td>
<td style="text-align:left">{:.0f}</td>
<td style="text-align:left">3</td>
<td style="text-align:left">不带小数</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">{:0&gt;2d}</td>
<td style="text-align:left">05</td>
<td style="text-align:left">数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">{:x&lt;4d}</td>
<td style="text-align:left">5xxx</td>
<td style="text-align:left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">{:x&lt;4d}</td>
<td style="text-align:left">10xx</td>
<td style="text-align:left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td style="text-align:left">1000000</td>
<td style="text-align:left">{:,}</td>
<td style="text-align:left">1,000,000</td>
<td style="text-align:left">以逗号分隔的数字格式</td>
</tr>
<tr>
<td style="text-align:left">0.25</td>
<td style="text-align:left">{:.2%}</td>
<td style="text-align:left">25.00%</td>
<td style="text-align:left">百分比格式</td>
</tr>
<tr>
<td style="text-align:left">1000000000</td>
<td style="text-align:left">{:.2e}</td>
<td style="text-align:left">1.00e+09</td>
<td style="text-align:left">指数记法</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">{:&gt;10d}</td>
<td style="text-align:left">13</td>
<td style="text-align:left">右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">{:&lt;10d}</td>
<td style="text-align:left">13</td>
<td style="text-align:left">左对齐 (宽度为10)</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">{:^10d}</td>
<td style="text-align:left">13</td>
<td style="text-align:left">中间对齐 (宽度为10)</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><code>'{:b}'.format(11) '{:d}'.format(11) '{:o}'.format(11) '{:x}'.format(11) '{:#x}'.format(11) '{:#X}'.format(11)</code></td>
<td style="text-align:left"><code>1011 11 13 b 0xb 0XB</code></td>
<td style="text-align:left">进制</td>
</tr>
</tbody>
</table>
<p><strong>^</strong>, <strong>&lt;</strong>, <strong>&gt;</strong> 分别是居中、左对齐、右对齐，后面带宽度， <strong>:</strong> 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。</p>
<p><strong>+</strong> 表示在正数前显示 <strong>+</strong>，负数前显示 <strong>-</strong>； （空格）表示在正数前加空格</p>
<p>b、d、o、x 分别是二进制、十进制、八进制、十六进制。</p>
<p><strong>例子5： % 符号格式化输出<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></strong></p>
<pre><code class="language-python">&gt;&gt;&gt;pi = 3.141592653  
&gt;&gt;&gt; print('%10.3f' % pi) #字段宽10，精度3  
     3.142  
&gt;&gt;&gt; print(&quot;pi = %.*f&quot; % (3,pi)) #用*从后面的元组中读取字段宽度或精度  
pi = 3.142  
&gt;&gt;&gt; print('%010.3f' % pi) #用0填充空白  
000003.142  
&gt;&gt;&gt; print('%-10.3f' % pi) #左对齐  
3.142       
&gt;&gt;&gt; print('%+f' % pi) #显示正负号  
+3.141593
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">符  号</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%c</td>
<td style="text-align:left">格式化字符及其ASCII码</td>
</tr>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:left">格式化字符串</td>
</tr>
<tr>
<td style="text-align:left">%d</td>
<td style="text-align:left">格式化整数</td>
</tr>
<tr>
<td style="text-align:left">%u</td>
<td style="text-align:left">格式化无符号整型</td>
</tr>
<tr>
<td style="text-align:left">%o</td>
<td style="text-align:left">格式化无符号八进制数</td>
</tr>
<tr>
<td style="text-align:left">%x</td>
<td style="text-align:left">格式化无符号十六进制数</td>
</tr>
<tr>
<td style="text-align:left">%X</td>
<td style="text-align:left">格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td style="text-align:left">%f</td>
<td style="text-align:left">格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td style="text-align:left">%e</td>
<td style="text-align:left">用科学计数法格式化浮点数</td>
</tr>
<tr>
<td style="text-align:left">%E</td>
<td style="text-align:left">作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td style="text-align:left">%g</td>
<td style="text-align:left">%f和%e的简写</td>
</tr>
<tr>
<td style="text-align:left">%G</td>
<td style="text-align:left">%f 和 %E 的简写</td>
</tr>
<tr>
<td style="text-align:left">%p</td>
<td style="text-align:left">用十六进制数格式化变量的地址</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">定义宽度或者小数点精度</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">用做左对齐</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">在正数前面显示加号( + )</td>
</tr>
<tr>
<td style="text-align:left"><sp></td>
<td style="text-align:left">在正数前面显示空格</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">显示的数字前面填充'0'而不是默认的空格</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">'%%'输出一个单一的'%'</td>
</tr>
<tr>
<td style="text-align:left">(var)</td>
<td style="text-align:left">映射变量(字典参数)</td>
</tr>
<tr>
<td style="text-align:left">m.n.</td>
<td style="text-align:left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>
</tr>
</tbody>
</table>
<p>例子6：<a href="https://blog.csdn.net/qq_44168690/article/details/104116406">Python中print的骚操作(倒计时、转圈显示、进度条)</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.runoob.com/python/att-string-format.html">1. Python format 格式化函数</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://www.runoob.com/w3cnote/python3-print-func-b.html">2. Python3 print 函数用法总结</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 日志模块 logging]]></title>
        <id>https://numantia.github.io/post/python-modules-logging/</id>
        <link href="https://numantia.github.io/post/python-modules-logging/">
        </link>
        <updated>2021-06-15T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E7%AE%80%E4%BB%8B-python-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%9D%97">1. 简介 Python 日志记录模块</a>
<ul>
<li><a href="#11-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">1.1 日志记录的重要性</a></li>
<li><a href="#12-logging%E6%A8%A1%E5%9D%97%E4%BC%98%E7%82%B9">1.2 Logging模块优点</a></li>
<li><a href="#13-%E5%B8%B8%E7%94%A8%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E6%AF%94%E8%BE%83">1.3 常用日志模块比较</a></li>
</ul>
</li>
<li><a href="#2-logging-%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81">2. Logging 模块组成和工作流</a>
<ul>
<li><a href="#21-logging-%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90">2.1 Logging 模块组成</a>
<ul>
<li><a href="#211-logging-%E6%A8%A1%E5%9D%97%E7%B1%BB">2.1.1 Logging 模块类</a></li>
<li><a href="#212-logging-%E6%A8%A1%E5%9D%97%E5%B1%82%E7%BA%A7%E5%87%BD%E6%95%B0">2.1.2 Logging 模块层级函数</a></li>
</ul>
</li>
<li><a href="#22-logging-%E5%B7%A5%E4%BD%9C%E6%B5%81">2.2 Logging 工作流</a></li>
<li><a href="#23-logging-%E9%85%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%B5%81">2.3 Logging 配置工作流</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%951loggingbasicconfig">方法1：logging.basicConfig()</a></li>
<li><a href="#%E6%96%B9%E6%B3%952%E7%9B%B4%E6%8E%A5-python-%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95">方法2：直接 Python 代码调用配置方法</a></li>
<li><a href="#%E6%96%B9%E6%B3%953%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9fileconfig">方法3：创建配置文件，从文件中读取配置内容（<code>fileConfig()</code> ）</a></li>
<li><a href="#%E6%96%B9%E6%B3%954%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E5%85%B8yaml-json%E4%BB%8E%E5%AD%97%E5%85%B8%E4%B8%AD%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9dictconfig">方法4：创建配置文件字典(YAML, JSON)，从字典中读取配置内容（<code>dictConfig()</code>）</a></li>
</ul>
</li>
<li><a href="#24-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">2.4 简单的例子</a></li>
</ul>
</li>
<li><a href="#3-logging-%E6%A8%A1%E5%9D%97%E7%94%A8%E6%B3%95">3. Logging 模块用法</a>
<ul>
<li><a href="#31-%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E5%88%B0%E6%96%87%E4%BB%B6%E5%92%8C%E5%B1%8F%E5%B9%95">3.1 日志写入到文件和屏幕</a></li>
<li><a href="#32-%E5%A4%9A%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BAlogging-from-multiple-modules">3.2 多模块输出（Logging from multiple modules）</a></li>
<li><a href="#33-logging-%E8%AE%B0%E5%BD%95-traceback-%E4%BF%A1%E6%81%AF">3.3 Logging 记录 Traceback 信息</a></li>
<li><a href="#34-%E8%BE%93%E5%87%BA%E8%BF%9B%E5%BA%A6%E4%BF%A1%E6%81%AF">3.4 输出进度信息</a></li>
</ul>
</li>
</ul>
</p>
<p>[TOC]</p>
<h1 id="1-简介-python-日志记录模块">1. 简介 Python 日志记录模块</h1>
<h2 id="11-日志记录的重要性">1.1 日志记录的重要性</h2>
<ol>
<li>部署到生产环境中的程序黑箱运行，无法通过调试程序来检查出现的问题，通过观察问题现象来调试，无法精准复现问题，修复问题棘手，会消耗大量时间</li>
<li>日志文件记录相关的时间记录，状态记录，错误记录等信息，方便地追踪运行状况，快速排查问题。</li>
</ol>
<h2 id="12-logging模块优点">1.2 Logging模块优点</h2>
<ol>
<li>
<p>方便日志按重要程度分级管理<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
</li>
<li>
<p>方便日志信息管理（额外日志信息的记录，如时间、运行模块信息）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
</li>
</ol>
<h2 id="13-常用日志模块比较">1.3 常用日志模块比较</h2>
<img src="https://numantia.github.io/post-images/log-recording-modules-comparison.jpg" alt="log-recording-modules-comparison" style="zoom:80%;float:center;" />
<p>​                                                                     图片摘自<a href="https://zhuanlan.zhihu.com/p/339961421">python输出日志</a></p>
<ul>
<li>print : 更加使用程序快速打印，不在乎日志格式，只想更快看到结果 ，一般用于程序的某个片段或者单点进行调试输出 。</li>
<li>pprint: 对元组，列表，字典数据打印更加直观友好，若输出的是这种格式，可以优先考虑pprint .</li>
<li>logging :对实现一个系统或框架时比较合适 ，且对日志需求有更高要求，可以优先考虑logging</li>
<li>loguru ：对实现一个系统或框架也比较合适 ，但是更加轻量化，不需要配置 ，若对日志需求要求不高，可优先考虑loguru</li>
</ul>
<h1 id="2-logging-模块组成和工作流">2. Logging 模块组成和工作流</h1>
<h2 id="21-logging-模块组成">2.1 Logging 模块组成</h2>
<ul>
<li>Logger：即 Logger Main Class，日志记录时创建的对象，我们可以调用Logger的方法传入日志模板和信息，来生成一条条日志记录，称作 Log Record。</li>
<li>Log Record：就代指生成的一条条日志记录。</li>
<li>Handler：处理日志记录的类，它可以将 Log Record 输出到指定的日志位置和存储形式等。</li>
<li>Formatter：生成的 Log Record 也是对象，输出日志文本的话，就需要有一个格式化的过程，那么这个过程就由 Formatter 来完成，返回的就是日志字符串，然后传回给 Handler 来处理。</li>
<li>Filter：保存前过滤，保存想要的日志，如只保存某个级别的日志，或只保存包含某个关键字的日志等，那么这个过滤过程就交给 Filter 来完成。</li>
</ul>
<p>以上就是整个 logging 模块的基本架构和对象功能<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，下面对Logging模块的对象及方法做简要的组成说明，详细参考[<a href="https://docs.python.org/3/library/logging.html#module-logging"><code>logging</code></a> — Logging facility for Python]</p>
<h3 id="211-logging-模块类">2.1.1 Logging 模块类</h3>
<pre><code class="language-bash">&gt;&gt;&gt; dir(logging.Logger)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_log', 'addFilter', 'addHandler', 'callHandlers', 'critical', 'debug', 'error', 'exception', 'fatal', 'filter', 'findCaller', 'getChild', 'getEffectiveLevel', 'handle', 'hasHandlers', 'info', 'isEnabledFor', 'log', 'makeRecord', 'manager', 'removeFilter', 'removeHandler', 'root', 'setLevel', 'warn', 'warning']
&gt;&gt;&gt; dir(logging.Handler)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'acquire', 'addFilter', 'close', 'createLock', 'emit', 'filter', 'flush', 'format', 'get_name', 'handle', 'handleError', 'name', 'release', 'removeFilter', 'setFormatter', 'setLevel', 'set_name']
&gt;&gt;&gt; dir(logging.Formatter)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'converter', 'default_msec_format', 'default_time_format', 'format', 'formatException', 'formatMessage', 'formatStack', 'formatTime', 'usesTime']
&gt;&gt;&gt; dir(logging.Filter)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'filter']
</code></pre>
<h3 id="212-logging-模块层级函数">2.1.2 Logging 模块层级函数</h3>
<p><code>logging.getLogger(name=None)</code></p>
<p><code>logging.getLoggerClass()</code></p>
<p><code>logging.debug(msg, *args, **kwargs)</code></p>
<p><code>logging.info(msg, *args, **kwargs)</code></p>
<p><code>logging.warning(msg, *args, **kwargs)</code></p>
<p><code>logging.error(msg, *args, **kwargs)</code></p>
<p><code>logging.critical(msg, *args, **kwargs)</code></p>
<p><code>logging.exception(msg, *args, **kwargs)</code></p>
<p><code>logging.basicConfig(**kwargs)</code></p>
<p><strong>Logging Level</strong></p>
<pre><code class="language-python">logger = logging.getLogger('simple_example')
logger.setLevel(logging.DEBUG)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">Level</th>
<th style="text-align:left">When it’s used</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>DEBUG</code></td>
<td style="text-align:left">Detailed information, typically of interest only when diagnosing problems.</td>
</tr>
<tr>
<td style="text-align:left"><code>INFO</code></td>
<td style="text-align:left">Confirmation that things are working as expected.</td>
</tr>
<tr>
<td style="text-align:left"><code>WARNING</code></td>
<td style="text-align:left">An indication that something unexpected happened, or indicative of some problem in the near future (e.g. ‘disk space low’). The software is still working as expected.</td>
</tr>
<tr>
<td style="text-align:left"><code>ERROR</code></td>
<td style="text-align:left">Due to a more serious problem, the software has not been able to perform some function.</td>
</tr>
<tr>
<td style="text-align:left"><code>CRITICAL</code></td>
<td style="text-align:left">A serious error, indicating that the program itself may be unable to continue running.</td>
</tr>
</tbody>
</table>
<p><strong>LogRecord attributes</strong></p>
<pre><code class="language-python">formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">Attribute name</th>
<th style="text-align:left">Format</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">args</td>
<td style="text-align:left">You shouldn’t need to format this yourself.</td>
<td style="text-align:left">The tuple of arguments merged into <code>msg</code> to produce <code>message</code>, or a dict whose values are used for the merge (when there is only one argument, and it is a dictionary).</td>
</tr>
<tr>
<td style="text-align:left">asctime</td>
<td style="text-align:left"><code>%(asctime)s</code></td>
<td style="text-align:left">Human-readable time when the <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> was created. By default this is of the form ‘2003-07-08 16:49:45,896’ (the numbers after the comma are millisecond portion of the time).</td>
</tr>
<tr>
<td style="text-align:left">created</td>
<td style="text-align:left"><code>%(created)f</code></td>
<td style="text-align:left">Time when the <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> was created (as returned by <a href="https://docs.python.org/3/library/time.html#time.time"><code>time.time()</code></a>).</td>
</tr>
<tr>
<td style="text-align:left">exc_info</td>
<td style="text-align:left">You shouldn’t need to format this yourself.</td>
<td style="text-align:left">Exception tuple (à la <code>sys.exc_info</code>) or, if no exception has occurred, <code>None</code>.</td>
</tr>
<tr>
<td style="text-align:left">filename</td>
<td style="text-align:left"><code>%(filename)s</code></td>
<td style="text-align:left">Filename portion of <code>pathname</code>.</td>
</tr>
<tr>
<td style="text-align:left">funcName</td>
<td style="text-align:left"><code>%(funcName)s</code></td>
<td style="text-align:left">Name of function containing the logging call.</td>
</tr>
<tr>
<td style="text-align:left">levelname</td>
<td style="text-align:left"><code>%(levelname)s</code></td>
<td style="text-align:left">Text logging level for the message (<code>'DEBUG'</code>, <code>'INFO'</code>, <code>'WARNING'</code>, <code>'ERROR'</code>, <code>'CRITICAL'</code>).</td>
</tr>
<tr>
<td style="text-align:left">levelno</td>
<td style="text-align:left"><code>%(levelno)s</code></td>
<td style="text-align:left">Numeric logging level for the message (<code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>).</td>
</tr>
<tr>
<td style="text-align:left">lineno</td>
<td style="text-align:left"><code>%(lineno)d</code></td>
<td style="text-align:left">Source line number where the logging call was issued (if available).</td>
</tr>
<tr>
<td style="text-align:left">message</td>
<td style="text-align:left"><code>%(message)s</code></td>
<td style="text-align:left">The logged message, computed as <code>msg % args</code>. This is set when <a href="https://docs.python.org/3/library/logging.html#logging.Formatter.format"><code>Formatter.format()</code></a> is invoked.</td>
</tr>
<tr>
<td style="text-align:left">module</td>
<td style="text-align:left"><code>%(module)s</code></td>
<td style="text-align:left">Module (name portion of <code>filename</code>).</td>
</tr>
<tr>
<td style="text-align:left">msecs</td>
<td style="text-align:left"><code>%(msecs)d</code></td>
<td style="text-align:left">Millisecond portion of the time when the <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> was created.</td>
</tr>
<tr>
<td style="text-align:left">msg</td>
<td style="text-align:left">You shouldn’t need to format this yourself.</td>
<td style="text-align:left">The format string passed in the original logging call. Merged with <code>args</code> to produce <code>message</code>, or an arbitrary object (see <a href="https://docs.python.org/3/howto/logging.html#arbitrary-object-messages">Using arbitrary objects as messages</a>).</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left"><code>%(name)s</code></td>
<td style="text-align:left">Name of the logger used to log the call.</td>
</tr>
<tr>
<td style="text-align:left">pathname</td>
<td style="text-align:left"><code>%(pathname)s</code></td>
<td style="text-align:left">Full pathname of the source file where the logging call was issued (if available).</td>
</tr>
<tr>
<td style="text-align:left">process</td>
<td style="text-align:left"><code>%(process)d</code></td>
<td style="text-align:left">Process ID (if available).</td>
</tr>
<tr>
<td style="text-align:left">processName</td>
<td style="text-align:left"><code>%(processName)s</code></td>
<td style="text-align:left">Process name (if available).</td>
</tr>
<tr>
<td style="text-align:left">relativeCreated</td>
<td style="text-align:left"><code>%(relativeCreated)d</code></td>
<td style="text-align:left">Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.</td>
</tr>
<tr>
<td style="text-align:left">stack_info</td>
<td style="text-align:left">You shouldn’t need to format this yourself.</td>
<td style="text-align:left">Stack frame information (where available) from the bottom of the stack in the current thread, up to and including the stack frame of the logging call which resulted in the creation of this record.</td>
</tr>
<tr>
<td style="text-align:left">thread</td>
<td style="text-align:left"><code>%(thread)d</code></td>
<td style="text-align:left">Thread ID (if available).</td>
</tr>
<tr>
<td style="text-align:left">threadName</td>
<td style="text-align:left"><code>%(threadName)s</code></td>
<td style="text-align:left">Thread name (if available).</td>
</tr>
</tbody>
</table>
<h2 id="22-logging-工作流">2.2 Logging 工作流</h2>
<img src="https://numantia.github.io/post-images/logging_flow.png" alt="logging_flow.png" style="zoom:80%;" />
<p>​                                                                  图片摘自官网<a href="https://docs.python.org/3/howto/logging.html#logging-flow">logging-basic-tutorial</a></p>
<h2 id="23-logging-配置工作流">2.3 Logging 配置工作流</h2>
<p>配置 logging 有四种方法</p>
<h3 id="方法1loggingbasicconfig">方法1：logging.basicConfig()</h3>
<pre><code class="language-python">&quot;&quot;&quot;
logging.basicConfig(
    filename,
    filemode,
    format,
    datefmt,
    style,
    level,
    stream,
    handlers
)
&quot;&quot;&quot;
import logging

_format = ('%(asctime)s '
           '%(name)s '  # the name of logger
           '%(levelname)s '
           '%(filename)s '
           '%(threadName)s '
           '%(lineno)d: '
           '%(message)s')
logging.basicConfig(
    level=logging.DEBUG,  # 默认 level 是 WARNING
    filename='test.log',
    format=_format,
)

logging.debug('logging debug')
logging.info('logging info')

</code></pre>
<h3 id="方法2直接-python-代码调用配置方法">方法2：直接 Python 代码调用配置方法</h3>
<img src="https://numantia.github.io/post-images/image-20210615161943846.png" alt="image-20210615161943846" style="zoom:80%;" />
<pre><code class="language-python">import logging

# create logger
logger = logging.getLogger('simple_example')
logger.setLevel(logging.DEBUG)

# create console handler and set level to debug
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

# create formatter
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# add formatter to ch
ch.setFormatter(formatter)

# add ch to logger
logger.addHandler(ch)

# 'application' code
logger.debug('debug message')
logger.info('info message')
logger.warning('warn message')
logger.error('error message')
logger.critical('critical message')
</code></pre>
<h3 id="方法3创建配置文件从文件中读取配置内容fileconfig">方法3：创建配置文件，从文件中读取配置内容（<a href="https://docs.python.org/3/library/logging.config.html#logging.config.fileConfig"><code>fileConfig()</code></a> ）</h3>
<pre><code class="language-python">import logging
import logging.config

logging.config.fileConfig('logging.conf')

# create logger
logger = logging.getLogger('simpleExample')

# 'application' code
logger.debug('debug message')
logger.info('info message')
logger.warning('warn message')
logger.error('error message')
logger.critical('critical message')
</code></pre>
<p>logging.conf (使用配置文件需去除批注)</p>
<pre><code class="language-bash">[loggers]
keys=root,simpleExample

[handlers]
keys=consoleHandler

[formatters]
keys=simpleFormatter

##########################################################
[logger_root] # 定义 root 的日志器，logger_key1
level=DEBUG
handlers=consoleHandler # 继承自[handlers]中key

[logger_simpleExample] # 定义 simpleExample 的日志器,logger_key2
level=DEBUG
handlers=consoleHandler
qualname=simpleExample # 继承自[loggers]中key
propagate=0

[handler_consoleHandler] # 定义窗口输出的处理器,handlers_key1
class=StreamHandler
level=DEBUG
formatter=simpleFormatter # 继承自[formatters]中key
args=(sys.stdout,)

[formatter_simpleFormatter] # 定义格式器，formatters_key1
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s
</code></pre>
<h3 id="方法4创建配置文件字典yaml-json从字典中读取配置内容dictconfig">方法4：创建配置文件字典(YAML, JSON)，从字典中读取配置内容（<a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig"><code>dictConfig()</code></a>）</h3>
<pre><code class="language-python">def setup_logging(default_path = &quot;config/logging.json&quot;, default_level = logging.INFO,env_key = &quot;LOG_CFG&quot;):
    path = default_path
    value = os.getenv(env_key,None)
    if value:
        path = value
    if os.path.exists(path):
        with open(path,&quot;r&quot;) as f:
            config = json.load(f)
            logging.config.dictConfig(config)
    else:
        logging.basicConfig(level = default_level)

if __name__ == '__main__':
    setup_logging(default_path = &quot;config/logging.json&quot;)
    main()
</code></pre>
<p><strong>配置文件：YAML format dictionary</strong></p>
<pre><code class="language-yaml">version: 1
formatters:
  simple:
    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
handlers:
  console:
    class: logging.StreamHandler
    level: DEBUG
    formatter: simple
    stream: ext://sys.stdout
loggers:
  simpleExample:
    level: DEBUG
    handlers: [console]
    propagate: no
root:
  level: DEBUG
  handlers: [console]
</code></pre>
<p><strong>配置文件：JSON format dictionary</strong> （去除#后内容方可使用）</p>
<pre><code class="language-json">{
    &quot;version&quot;:1,
    &quot;disable_existing_loggers&quot;:false,
    &quot;formatters&quot;:{
        &quot;simple&quot;:{
            &quot;format&quot;:&quot;%(asctime)s - %(name)s - %(filename)s  - %(funcName)s - %(lineno)d- %(levelname)s - %(message)s&quot;
        }
    },
    &quot;handlers&quot;:{
        &quot;console&quot;:{
            &quot;class&quot;:&quot;logging.StreamHandler&quot;,
            &quot;level&quot;:&quot;DEBUG&quot;, # 设置 handlers 的输出级别，下一级
            &quot;formatter&quot;:&quot;simple&quot;,
            &quot;stream&quot;:&quot;ext://sys.stdout&quot;
        },
        &quot;info_file_handler&quot;:{
            &quot;class&quot;:&quot;logging.handlers.RotatingFileHandler&quot;,
            &quot;level&quot;:&quot;INFO&quot;, # 设置 handlers 的输出级别，下一级
            &quot;formatter&quot;:&quot;simple&quot;,
            &quot;filename&quot;:&quot;log/info.log&quot;,
            &quot;maxBytes&quot;:40960,
            &quot;backupCount&quot;:20,
            &quot;encoding&quot;:&quot;utf8&quot;
        },
        &quot;error_file_handler&quot;:{
            &quot;class&quot;:&quot;logging.handlers.RotatingFileHandler&quot;,
            &quot;level&quot;:&quot;ERROR&quot;, # 设置 handlers 的输出级别，下一级
            &quot;formatter&quot;:&quot;simple&quot;,
            &quot;filename&quot;:&quot;log/errors.log&quot;,
            &quot;maxBytes&quot;:40960, # 单个文件大小 1024*40
            &quot;backupCount&quot;:20, #备份文件数目 20个文件
            &quot;encoding&quot;:&quot;utf8&quot;
        }
    },
    &quot;loggers&quot;:{
        &quot;my_module&quot;:{
            &quot;level&quot;:&quot;ERROR&quot;, # 设置 Logger 的输出级别
            &quot;handlers&quot;:[&quot;info_file_handler&quot;],
            &quot;propagate&quot;:&quot;no&quot;
        }
    },
    &quot;root&quot;:{
        &quot;level&quot;:&quot;INFO&quot;,
        &quot;handlers&quot;:[&quot;console&quot;,&quot;info_file_handler&quot;,&quot;error_file_handler&quot;]
    }
}
</code></pre>
<h2 id="24-简单的例子">2.4 简单的例子</h2>
<pre><code class="language-python">import logging
import logging.handlers

logger = logging.getLogger('test')
logger.setLevel(level=logging.DEBUG)  # 记录日志的级别
&quot;&quot;&quot;
%(name)s：Logger的名字
%(levelno)s：打印日志级别的数值
%(levelname)s：打印日志级别的名称
%(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]
%(filename)s：打印当前执行程序名
%(funcName)s：打印日志的当前函数
%(lineno)d：打印日志的当前行号
%(asctime)s：打印日志的时间
%(thread)d：打印线程ID
%(threadName)s：打印线程名称
%(process)d：打印进程ID
%(message)s：打印日志信息
&quot;&quot;&quot;

formatter = logging.Formatter('%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')
&quot;&quot;&quot;
logging.StreamHandler -&gt; 控制台输出
logging.FileHandler -&gt; 文件输出
logging.handlers.RotatingFileHandler -&gt; 按照大小自动分割日志文件，一旦达到指定的大小重新生成文件
logging.handlers.TimedRotatingFileHandler -&gt; 按照时间自动分割日志文件
&quot;&quot;&quot;
file_handler = logging.FileHandler('log/test.log') # 输出文件日志的位置方式，添加文件位置
file_handler.setLevel(level=logging.INFO) # 输出文件日志的级别 
file_handler.setFormatter(formatter) # 输出文件日志的格式

stream_handler = logging.StreamHandler() # 输出屏幕日志的位置方式
stream_handler.setLevel(logging.DEBUG) # 输出屏幕日志的级别
stream_handler.setFormatter(formatter) # 输出屏幕日志的格式

# time_rotating_file_handler = logging.handlers.TimedRotatingFileHandler(filename='rotating_test.log', when='D')
# time_rotating_file_handler.setLevel(logging.DEBUG)
# time_rotating_file_handler.setFormatter(formatter)

logger.addHandler(file_handler)
logger.addHandler(stream_handler)
# logger.addHandler(time_rotating_file_handler)

# 运行测试
logger.debug('debug级别，一般用来打印一些调试信息，级别最低')
logger.info('info级别，一般用来打印一些正常的操作信息')
logger.warning('waring级别，一般用来打印警告信息')
logger.error('error级别，一般用来打印一些错误信息')
logger.critical('critical级别，一般用来打印一些致命的错误信息，等级最高')
</code></pre>
<h1 id="3-logging-模块用法">3. Logging 模块用法</h1>
<h2 id="31-日志写入到文件和屏幕">3.1 日志写入到文件和屏幕</h2>
<p>输出到文件：设置logging，创建一个FileHandler，并对输出消息的格式进行设置，将其添加到logger，然后将日志写入到指定的文件中</p>
<p>输出到屏幕： logger中添加StreamHandler，可以将日志输出到屏幕上</p>
<p>其他不同的 Handler 方式</p>
<pre><code>StreamHandler：logging.StreamHandler；日志输出到流，可以是sys.stderr，sys.stdout或者文件
FileHandler：logging.FileHandler；日志输出到文件
BaseRotatingHandler：logging.handlers.BaseRotatingHandler；基本的日志回滚方式
RotatingHandler：logging.handlers.RotatingHandler；日志回滚方式，支持日志文件最大数量和日志文件回滚
TimeRotatingHandler：logging.handlers.TimeRotatingHandler；日志回滚方式，在一定时间区域内回滚日志文件
SocketHandler：logging.handlers.SocketHandler；远程输出日志到TCP/IP sockets
DatagramHandler：logging.handlers.DatagramHandler；远程输出日志到UDP sockets
SMTPHandler：logging.handlers.SMTPHandler；远程输出日志到邮件地址
SysLogHandler：logging.handlers.SysLogHandler；日志输出到syslog
NTEventLogHandler：logging.handlers.NTEventLogHandler；远程输出日志到Windows NT/2000/XP的事件日志
MemoryHandler：logging.handlers.MemoryHandler；日志输出到内存中的指定buffer
HTTPHandler：logging.handlers.HTTPHandler；通过&quot;GET&quot;或者&quot;POST&quot;远程输出到HTTP服务器
</code></pre>
<p>同时输出达到屏幕和文件可参考下一节。</p>
<h2 id="32-多模块输出logging-from-multiple-modules">3.2 多模块输出（<a href="https://docs.python.org/3/howto/logging.html#logging-from-multiple-modules">Logging from multiple modules</a>）</h2>
<p><strong>例子1：</strong> 最简单例子解释使用模式</p>
<pre><code class="language-python"># myapp.py
import logging
import mylib

def main():
    logging.basicConfig(filename='myapp.log', level=logging.INFO)
    logging.info('Started')
    mylib.do_something()
    logging.info('Finished')

if __name__ == '__main__':
    main()
</code></pre>
<pre><code class="language-python">    # mylib.py
    import logging

    def do_something():
        logging.info('Doing something')
</code></pre>
<pre><code class="language-cmd">输出
&gt;&gt;&gt; 
INFO:root:Started
INFO:root:Doing something
INFO:root:Finished
</code></pre>
<p><strong>例子2：</strong> 多模块追踪信息来源<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<pre><code class="language-python"># mainModule.py

import logging
import subModule
logger = logging.getLogger(&quot;mainModule&quot;) # 主模块定义了logger'mainModule'，在python解释器进程其他模块里都可以使用logger对象，不需要反复的定义和配置各个模块的logger
logger.setLevel(level = logging.INFO)
handler = logging.FileHandler(&quot;log.txt&quot;)
handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
 
console = logging.StreamHandler()
console.setLevel(logging.INFO)
console.setFormatter(formatter)
 
logger.addHandler(handler)
logger.addHandler(console)
 
 
logger.info(&quot;creating an instance of subModule.subModuleClass&quot;)
a = subModule.SubModuleClass()
logger.info(&quot;calling subModule.subModuleClass.doSomething&quot;)
a.doSomething()
logger.info(&quot;done with  subModule.subModuleClass.doSomething&quot;)
logger.info(&quot;calling subModule.some_function&quot;)
subModule.som_function()
logger.info(&quot;done with subModule.some_function&quot;)
</code></pre>
<pre><code class="language-python">import logging
 
module_logger = logging.getLogger(&quot;mainModule.sub&quot;) # 任意以'mainModule'开头的logger都是它的子logger
class SubModuleClass(object):
    def __init__(self):
        self.logger = logging.getLogger(&quot;mainModule.sub.module&quot;)
        self.logger.info(&quot;creating an instance in SubModuleClass&quot;)
    def doSomething(self):
        self.logger.info(&quot;do something in SubModule&quot;)
        a = []
        a.append(1)
        self.logger.debug(&quot;list a = &quot; + str(a))
        self.logger.info(&quot;finish something in SubModuleClass&quot;)
 
def som_function():
    module_logger.info(&quot;call function some_function&quot;)
</code></pre>
<pre><code class="language-cmd">输出
&gt;&gt;&gt;
2016-10-09 20:25:42,276 - mainModule - INFO - creating an instance of subModule.subModuleClass
2016-10-09 20:25:42,279 - mainModule.sub.module - INFO - creating an instance in SubModuleClass
2016-10-09 20:25:42,279 - mainModule - INFO - calling subModule.subModuleClass.doSomething
2016-10-09 20:25:42,279 - mainModule.sub.module - INFO - do something in SubModule
2016-10-09 20:25:42,279 - mainModule.sub.module - INFO - finish something in SubModuleClass
2016-10-09 20:25:42,279 - mainModule - INFO - done with  subModule.subModuleClass.doSomething
2016-10-09 20:25:42,279 - mainModule - INFO - calling subModule.some_function
2016-10-09 20:25:42,279 - mainModule.sub - INFO - call function some_function
2016-10-09 20:25:42,279 - mainModule - INFO - done with subModule.some_function
</code></pre>
<h2 id="33-logging-记录-traceback-信息">3.3 Logging 记录 Traceback 信息</h2>
<p>Python中的traceback模块被用于跟踪异常返回信息，可以在logging中记录下traceback.改部分摘自参考文章<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>。</p>
<pre><code class="language-python">import logging
logger = logging.getLogger(__name__)
logger.setLevel(level = logging.INFO)
handler = logging.FileHandler(&quot;log.txt&quot;)
handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
 
console = logging.StreamHandler()
console.setLevel(logging.INFO)
 
logger.addHandler(handler)
logger.addHandler(console)
 
logger.info(&quot;Start print log&quot;)
logger.debug(&quot;Do something&quot;)
logger.warning(&quot;Something maybe fail.&quot;)
try:
    open(&quot;sklearn.txt&quot;,&quot;rb&quot;)
except (SystemExit,KeyboardInterrupt):
    raise
except Exception:
    logger.error(&quot;Faild to open sklearn.txt from logger.error&quot;,exc_info = True) # 方法1
    logger.exception(&quot;Failed to open sklearn.txt from logger.exception&quot;) # 方法2
 
logger.info(&quot;Finish&quot;)
</code></pre>
<pre><code>Start print log
Something maybe fail.
Faild to open sklearn.txt from logger.error
Traceback (most recent call last):
  File &quot;G:\zhb7627\Code\Eclipse WorkSpace\PythonTest\test.py&quot;, line 23, in &lt;module&gt;
    open(&quot;sklearn.txt&quot;,&quot;rb&quot;)
IOError: [Errno 2] No such file or directory: 'sklearn.txt'
Finish
</code></pre>
<h2 id="34-输出进度信息">3.4 输出进度信息</h2>
<pre><code class="language-python">logging.info(&quot;Operating progress: {:.1f}%, {} &quot;.format(num/cycle_No*100, &quot;&gt;&quot; * (num // 2)))
</code></pre>
<p>https://zhuanlan.zhihu.com/p/56095714</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://docs.python.org/3/library/logging.html#logging-levels">1. Logging Levels</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://docs.python.org/3/library/logging.html#logrecord-attributes">2. logrecord-attributes</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://blog.csdn.net/pansaky/article/details/90710751?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162322535616780269881668%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162322535616780269881668&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-8-90710751.first_rank_v2_pc_rank_v29&amp;utm_term=python+%E6%97%A5%E5%BF%97&amp;spm=1018.2226.3001.4187">3.python 日志 logging模块(详细解析)</a> <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a href="https://cuiqingcai.com/6080.html">4. Python 中 logging 模块的基本用法</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 文件夹操作]]></title>
        <id>https://numantia.github.io/post/python-dir-operation/</id>
        <link href="https://numantia.github.io/post/python-dir-operation/">
        </link>
        <updated>2021-06-14T18:09:44.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">import os, re, shutil

class  file_operation(object):
    def __init__(self, file_dir='.', layer=1):
        &quot;&quot;&quot;[file operation initilization]

        Parameters
        ----------
        file_dir : str, optional
            [objective directory path], by default '.'
        &quot;&quot;&quot;
        self.file_dir = file_dir
        self.layer = layer
        
    def get_files(self):
        &quot;&quot;&quot;[Only get filepath name in the specified directory exculde files in the sub-directory]

        Parameters
        ----------
        None

        Returns
        -------
        [str list]
            [return filelists]
        &quot;&quot;&quot;
 
        # check whether filr_dir is None
        if self.file_dir == None:
            self.file_dir = os.getcwd()
        
        if self.layer == 1:
            list_both = os.listdir(self.file_dir)  
            # read files and directories both at first level of directory
            rel_filelist = [item for item in list_both if os.path.isfile(os.path.join(self.file_dir, item))]
            abs_filelist = [os.path.join(self.file_dir,item) for item in list_both if os.path.isfile(os.path.join(self.file_dir, item))]
            # os.path.isfile 接收的参数是路径+文件名 
            # os.path 模块稍后会讲到
        if self.layer == 2:
            # Iterate through all folders including sub-directory
            rel_filelist = []
            abs_filelist = []
            for filepath,dirnames,filenames in os.walk(self.file_dir):
                for filename in filenames:
                    rel_filelist.append(filename)
                    abs_filelist.append(os.path.join(filepath,filename))
        return rel_filelist, abs_filelist
    
    def get_fotmatted_files(self, file_format=['.csv']):
        &quot;&quot;&quot;[Only get specied formatted filepath name in the specified directory exculde files in the sub-directory]

        Parameters
        ----------
        file_dir : str, optional
            [current file directory path], by default '.'

        Returns
        -------
        [str list]
            [return filelist_filt]
        &quot;&quot;&quot;
        rel_filelist, abs_filelist = file_operation.get_files(self)
        filelist_filt = [file for file in abs_filelist if os.path.splitext(file)[1] in file_format]
        return filelist_filt
    
    def make_dir(self, file_format, regex, group_num=1):
        abs_filelist = file_operation.get_fotmatted_files(self, file_format)
        match_no_duplicate  = []
        for item in abs_filelist:
            match = regex.search(item).group(group_num)
            if match not in match_no_duplicate:
                match_no_duplicate.append(match)
                os.mkdir(os.path.join(self.file_dir, match))
                print(&quot;{} 文件夹已创建&quot;.format(match))

    def move_file(self, out_dir, abs_filelist, regex, group_num=1):
        &quot;&quot;&quot;[usuage 01: filter filelist using regular expression, move filtered files into predefined directory]

        Parameters
        ----------
        out_dir : [type]
            [description]
        abs_filelist : [type]
            [description]
        regex : [re]
            [regular expression]
        group_num : int, optional
            [group No], by default 1
        &quot;&quot;&quot;
        print(self.file_dir)
        for item in abs_filelist:
            try:
                match = regex.search(item).group(group_num)
                src = os.path.join(self.file_dir, match)
                dst = out_dir
                print('src:', src)
                print('dst:', dst)
                shutil.copy(src, dst)
            except:
                print(&quot;{}文件不匹配&quot;.format(item))
                continue
    
    def mkdir_move_file(self, file_format, regex, group_num=1):
        &quot;&quot;&quot;[usuage 02: iterate over each of file, move them to corresponding directory]

        Parameters
        ----------
        file_format : [str list]
            [format string list]
        regex : [re]
            [regular expression]
        group_num : int, optional
            [group No], by default 1
        &quot;&quot;&quot;
        print(self.file_dir)
        abs_filelist = file_operation.get_fotmatted_files(self, file_format)
        file_operation.make_dir(self, file_format,regex,group_num)
        for item in abs_filelist:
            match = regex.search(item).group(group_num)   
            src = item
            dst = os.path.join(self.file_dir, match)
            print('src:', src)
            print('dst:', dst)
            shutil.copy(src, dst)
</code></pre>
<p>https://zhuanlan.zhihu.com/p/150835193</p>
<p>https://blog.csdn.net/CrozonKDD/article/details/79305235</p>
<p>https://blog.csdn.net/silentwolfyh/article/details/74931123</p>
<p>https://blog.csdn.net/u013171226/article/details/107680283</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pip 软件源管理（一次性解决下载缓慢问题）]]></title>
        <id>https://numantia.github.io/post/pip-software-source-management/</id>
        <link href="https://numantia.github.io/post/pip-software-source-management/">
        </link>
        <updated>2021-06-07T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="临时修改">临时修改</h1>
<pre><code class="language-bash">pip install tensorflow -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
</code></pre>
<h1 id="pip-config-修改">pip config 修改</h1>
<pre><code class="language-bash"># 清华源
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
# 或：
# 阿里源
pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/
# 腾讯源
pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple
# 豆瓣源
pip config set global.index-url http://pypi.douban.com/simple/
</code></pre>
<h1 id="修改配置文件">修改配置文件</h1>
<pre><code class="language-bash">Linux:
修改 pip.conf 文件 (没有就创建一个)
$HOME/.config/pip/pip.conf
修改内容如下：
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple12

Mac:
修改 pip.conf 文件
$HOME/Library/Application Support/pip/pip.conf
如果没有上面的目录,在如下目录创建 pip.conf
$HOME/.config/pip/pip.conf
修改内容如下：
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple12

Windows:
修改 pip.conf 文件 (没有就创建一个)
%APPDATA%\pip\pip.ini
修改内容如下：
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 编程常见问题集]]></title>
        <id>https://numantia.github.io/post/python-FAQs/</id>
        <link href="https://numantia.github.io/post/python-FAQs/">
        </link>
        <updated>2021-06-03T18:09:44.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<p><ul class="markdownIt-TOC">
<li><a href="#import-module">Import Module</a>
<ul>
<li><a href="#1-typeerror-module-object-is-not-callable">1. TypeError: 'module' object is not callable</a></li>
<li><a href="#unboundlocalerror-local-variable-xxx-referenced-before-assignment">UnboundLocalError： local variable 'xxx' referenced before assignment</a></li>
</ul>
</li>
<li><a href="#data-type-and-conversion">Data type and Conversion</a></li>
<li><a href="#string">String</a>
<ul>
<li><a href="#1-typeerror-str-object-is-not-callable">1. TypeError: 'str' object is not callable</a></li>
<li><a href="#2-string-%E5%88%87%E7%89%87%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA%E9%80%86%E5%BA%8F%E5%9F%BA%E6%95%B0%E8%BE%93%E5%87%BA">2. String 切片逆序输出，逆序基数输出</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99">文件读写</a>
<ul>
<li><a href="#1-%E5%AF%BC%E5%87%BA-csv-%E5%AD%98%E5%9C%A8%E7%A9%BA%E7%99%BD%E8%A1%8C%E9%9A%94%E8%A1%8C%E7%A9%BA%E8%A1%8C">1. 导出 csv 存在空白行/隔行空行</a></li>
<li><a href="#2-%E5%A4%9A%E4%B8%AA-print-%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9%E5%9C%A8%E5%90%8C%E4%B8%80%E8%A1%8C">2. 多个 Print() 显示内容在同一行</a></li>
<li><a href="#3-permissionerror-errno-13-permission-denied">3. PermissionError: [Errno 13] Permission denied</a></li>
<li><a href="#4-unicodedecodeerror-utf-8-codec-cant-decode-byte-oxc1-in-position-0">4. UnicodeDecodeError: ‘utf-8’ codec can't decode byte oxc1 in position 0</a></li>
</ul>
</li>
<li><a href="#numpy">Numpy</a>
<ul>
<li><a href="#1-numpy-%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E6%95%B0%E5%AD%97%E7%B4%A2%E5%BC%95%E5%80%BC">1. numpy 获取对应数字索引值</a></li>
<li><a href="#2-npdelete-%E6%96%B9%E6%B3%95">2. np.delete() 方法</a></li>
<li><a href="#3-numpy%E4%B8%AD%E6%89%BE%E5%89%8D%E5%87%A0%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC">3. numpy中找前几个最大值/最小值</a></li>
<li><a href="#4-ndarray-%E5%88%A4%E6%96%AD%E7%A9%BA%E4%B8%8E%E9%9D%9E%E7%A9%BA">4. ndarray 判断空与非空</a></li>
<li><a href="#5-npall-%E5%92%8C-npany%E7%9A%84%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90">5. np.all 和 np.any的用法解析</a></li>
<li><a href="#6-nppad%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3">6. np.pad()的用法详解</a></li>
</ul>
</li>
<li><a href="#pandas">Pandas</a>
<ul>
<li><a href="#1-%E5%AD%97%E5%85%B8%E5%88%9B%E5%BB%BA-dataframe-%E9%95%BF%E5%BA%A6%E4%B8%8D%E4%B8%80%E8%87%B4%E5%87%BA%E9%94%99">1. 字典创建 DataFrame 长度不一致出错</a></li>
<li><a href="#2-pandas-to-excel-%E5%AD%98%E5%82%A8%E4%B8%8D%E5%90%8C-sheet">2. Pandas to-excel() 存储不同 Sheet</a></li>
<li><a href="#3-pandas-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E8%A1%A8%E6%A0%BC%E5%A4%8D%E5%88%B6%E5%90%8C%E6%AD%A5%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98">3. Pandas 浅拷贝和深拷贝 - 表格复制同步修改问题</a></li>
</ul>
</li>
</ul>
</p>
<p>持续更新...</p>
<p>指数幂和n次方根</p>
<pre><code class="language-python">import math

math.pow( x, y )
x**y

# a的r次方
math.pow(a, 1/r)

pow(x,y,z) 等价于 x**y%z
4**2.5%3  # 结果为2.0
</code></pre>
<h1 id="import-module">Import Module</h1>
<h2 id="1-typeerror-module-object-is-not-callable">1. TypeError: 'module' object is not callable</h2>
<p><strong>产生原因</strong></p>
<p>模块前面未加模块名限定</p>
<p><strong>解决方法</strong></p>
<pre><code class="language-python">Python导入模块的方法有两种：
import module  # 所有导入的方法使用时需加上模块名的限
from module import *  # 无需模块名
</code></pre>
<h2 id="unboundlocalerror-local-variable-xxx-referenced-before-assignment">UnboundLocalError： local variable 'xxx' referenced before assignment</h2>
<p><strong>产生原因</strong></p>
<p>外部定义了变量，函数内部对该变量运算时</p>
<pre><code class="language-python">def test():
       if value == 1:
              a += 1  # 赋值操作a就会被认为是局部变量，而非全局变量
       return a  # return 或者 print 操作，由于局部变量a未定义，因此就会报错

value = a = 1
b = test()
</code></pre>
<p><strong>解决方法</strong></p>
<pre><code class="language-python"># a 定义为全局变量
def test():
       global a
       if value == 1:
              a += 1
       return a

value = a = 1
b = test()

# a 在函数内部定义为局部变量
def test():
　　  a = 1
       if value == 1:
              a += 1
       return a

value = a = 1
b = test()
</code></pre>
<h1 id="data-type-and-conversion">Data type and Conversion</h1>
<p>https://blog.csdn.net/vivian_python/article/details/102968868</p>
<p>https://blog.csdn.net/nameix/article/details/54341949</p>
<p>首先：表现形式不一致：list：[];字典{}；元组（）集合{}；</p>
<p>其次：python的列表各个元素可以是不一致的类型即[1,&quot;asd&quot;,10.25]；字典得有key-value，且key不能重复；元组不可以修改，是只读的list,但对于可变数据类型是可以修改的如：a=（1，2，[5,6,7]）,a[-1][-1]=2,则a=[1，2，2]；集合的元素不能有重复；</p>
<p>最后：类型转换：list（）；set（）；dict（）；tuple（）</p>
<p>比如删除list的重复元素，直接将其变换成set类型即可，然后在list变成列表。</p>
<p>List</p>
<p>dict</p>
<p>可存储长度不同，文件类型可以不一</p>
<p>np.array</p>
<p>长度必须一致</p>
<pre><code class="language-python"># 查看格式
print(type(1),type(3.14),
      type('a'),type('abd'),
      type((1,2,3)),type(True),type(None),
      type([]),type({1,2}),type({1:'monday',2:'tuesday'}))

# 强制类型转换
f = 3.14
print('f=%f,int(f)=%d '%(f,int(f)))
print(float(int(f)))
print(chr(65)) #整数转化为ascii码字符
print(ord('a')) #ascii字符转化为整数

# 转成布尔类型 bool()
print(bool('1'),bool('0'),bool([0])) #True
print(bool(''),bool(0),bool([]),bool(()),bool({})) #False

# 字符串 str()
print(type(str(f)))

# 加 r 忽略转义字符
print('c:\\\\user\\\\pycharm') #\\\\转义\\
print(r'c:\\user\\pycharm') #用r无需加转义
</code></pre>
<h1 id="string">String</h1>
<h2 id="1-typeerror-str-object-is-not-callable">1. TypeError: 'str' object is not callable</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; x=1.235
&gt;&gt;&gt; int(x)
1
&gt;&gt;&gt; str=&quot;fsgavfdbafdbntsbgbt&quot;
&gt;&gt;&gt; len(str)
19
&gt;&gt;&gt;
&gt;&gt;&gt; x=987456123
&gt;&gt;&gt; str(x)
TypeError: 'str' object is not callable
</code></pre>
<p><strong>产生原因</strong></p>
<p>str 为内部函数，str 变量赋值将其转化为变量，发生冲突，无法调用</p>
<p><strong>解决方法</strong></p>
<p>更改变量名，和系统内置函数名称<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>不重复</p>
<h2 id="2-string-切片逆序输出逆序基数输出">2. String 切片逆序输出，逆序基数输出</h2>
<p>name[::-1],没有写数字，默认为0，两个冒号表示从头到尾，以-1为间隔输出，即逆序输出全部</p>
<p>name[::-2]，以-1为间隔输出，即逆序输出奇数下标元素</p>
<h1 id="文件读写">文件读写</h1>
<h2 id="1-导出-csv-存在空白行隔行空行">1. 导出 csv 存在空白行/隔行空行</h2>
<pre><code class="language-python">with open(test.csv,'w',newline='') as f:
</code></pre>
<h2 id="2-多个-print-显示内容在同一行">2. 多个 Print() 显示内容在同一行</h2>
<p><strong>产生原因</strong></p>
<p>原理：Print 函数输出最后一个值缺省为换行符，由<code>end= '\n'</code>指定 , 去掉 <code>\n</code> ，即可实现不换行</p>
<pre><code class="language-python">print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)

    Prints the values to a stream, or to sys.stdout by default.
    Optional keyword arguments:
    file:  a file-like object (stream); defaults to the current sys.stdout.
    sep:   string inserted between values, default a space.
    end:   string appended after the last value, default a newline.
    flush: whether to forcibly flush the stream.
</code></pre>
<p><strong>解决方法</strong></p>
<pre><code class="language-python">print('hello,',end = '')
print('world')
&gt;&gt;&gt; hello,world
</code></pre>
<h2 id="3-permissionerror-errno-13-permission-denied">3. PermissionError: [Errno 13] Permission denied</h2>
<p><strong>问题描述</strong></p>
<p>保存CSV，路径为<strong>文件名</strong>，有访问权限，部分数据已顺利存储进入，继续运行，报错<code>PermissionError: [Errno 13] Permission denied</code></p>
<p><strong>产生原因</strong></p>
<p><a href="https://blog.csdn.net/shuiyixin/article/details/90370387?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.control">文章</a> 指出有三个原因造成该错误，第一是缺乏访问权限，第二是路径为<strong>文件夹名</strong>，而非文件名，第三为改文件打开。这里补充一个原因，该文件夹默认添加到云盘（Onedrive，Icloud，坚果云等）的同步文件夹中，同步操作时该文件无添加权限。</p>
<p><strong>解决方法</strong></p>
<p>关闭同步软件</p>
<h2 id="4-unicodedecodeerror-utf-8-codec-cant-decode-byte-oxc1-in-position-0">4. UnicodeDecodeError: ‘utf-8’ codec can't decode byte oxc1 in position 0</h2>
<p>对于<strong>中文的文本文件常容易因为编码的问题而读取失败</strong>，正如上图所示。遇到这样的编码问题该如何处置呢？解决办法有两种情况：</p>
<p>1）当原始文件txt或csv的数据不是uft8格式时，需要另存为utf8格式编码；</p>
<p>2）如果原始的数据文件就是uft8格式，为了正常读入，需要将read_csv函数的参数encoding设置为utf-8</p>
<h1 id="numpy">Numpy</h1>
<h2 id="1-numpy-获取对应数字索引值">1. numpy 获取对应数字索引值</h2>
<pre><code class="language-python">q=np.arange(0,16,1)
g=np.where(q==7)
print q
print g

[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]
(array([7]),)

q=np.arange(0,16,1)
g=np.argwhere(q==7) # 注意这里，返回索引值的列表
print q
print g
print int(g) # 转化为可运算的数字序列

[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]
[[7]]
7
</code></pre>
<h2 id="2-npdelete-方法">2. np.delete() 方法</h2>
<p>numpy.delete()适用于numpy ndarray数组。但是numpy数组不支持删除数组元素，numpy.delete() 返回删除了某些元素的新数组。</p>
<pre><code class="language-python">numpy.delete(arr,obj,axis = None)
</code></pre>
<p>arr : 输入向量</p>
<p>obj : 表明哪一个子向量应该被移除（index）。可以为整数或一个int型的向量</p>
<p>axis : 表明删除哪个轴的子向量，若默认，则返回一个被拉平的向量</p>
<p>例子</p>
<pre><code class="language-python">import numpy as np
a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
index = [2, 3, 6]
new_a = np.delete(a, index)
print(new_a) #Prints `[1, 2, 5, 6, 8, 9]
</code></pre>
<h2 id="3-numpy中找前几个最大值最小值">3. numpy中找前几个最大值/最小值</h2>
<p>方法1：</p>
<pre><code class="language-python">def find_max(a):
    b = np.zeros(4)
    c = np.zeros(4)
    c[0] = np.max(a)    #最大值
    b[0] = np.where(a==c[0])[0]     #最大``值位置
    new_a = np.delete(a,b[0])

    c[1] = np.max(new_a)    #次大值
    b[1] = np.where(new_a==c[1])[0]     #找出次大值位置。注：位置为新数组位置，无意义
    new_a1 = np.delete(new_a,b[1])

    c[2] = np.max(new_a1)   #第三大值
    b[2] = np.where(new_a1==c[2] )[0]   #找出第三大值位置
    new_a2 = np.delete(new_a1,b[2])

    c[3] = np.max(new_a2)   #第四大值
    b[3] = np.where(new_a2==c[3])[0]    #找出第四大值位置
    return b,c
</code></pre>
<p>方法2：</p>
<pre><code class="language-python">&gt;&gt;&gt; import heapq
&gt;&gt;&gt; nums=[1,8,2,23,7,-4,18,23,42,37,2]
&gt;&gt;&gt; print(heapq.nlargest(3,nums))
[42, 37, 23]
&gt;&gt;&gt; print(heapq.nsmallest(3,nums))
[-4, 1, 2]
</code></pre>
<h2 id="4-ndarray-判断空与非空">4. ndarray 判断空与非空</h2>
<p>方法1：</p>
<pre><code class="language-python"># 一维数组
array = np.array([])
if array:
    print('非空')
if not array:
    print('空')
# 二维数组
array = np.array([[1], []])
if array.any():
    print('非空')
if not array.any():
    print('空')
</code></pre>
<h2 id="5-npall-和-npany的用法解析">5. np.all 和 np.any的用法解析</h2>
<p><strong>一维数组</strong></p>
<p><code>np.all((a, axis=None, out=None, keepdims=np._NoValue))</code> : 判断给定轴上所有元素是否***都为 True***，如果<code>axis</code>为None，返回单个布尔值True或False。</p>
<pre><code class="language-python">a1 = np.arange(5)       # 生成一个矩阵 [0  1  2  3  4]
print(&quot;np.all(a1):&quot;, np.all(a2))    # 并运算，未输入axis，输出：False
</code></pre>
<p><code>any(a, axis=None, out=None, keepdims=np._NoValue)</code> : 断给定轴向上***是否有一个元素为True***</p>
<pre><code class="language-python">a2 = np.arange(5)       # 生成一个矩阵 [0  1  2  3  4]
print(&quot;np.any(a2):&quot;, np.any(a2))    # 输出：True
</code></pre>
<p><strong>二维数组</strong></p>
<pre><code class="language-python">b1 = np.arange(36).reshape(2, 3, 6)     # # 创建一个2*3*6矩阵`
print(&quot;np.all(b1):&quot;, np.all(b1))    # 判断矩阵中所有元素是否都为True
&gt;&gt;&gt; np.all(b1): False
print(&quot;np.all(b1):&quot;, np.all(b1))    # 判断矩阵中所有元素是否都为True
&gt;&gt;&gt; np.any(b1): True
</code></pre>
<p><strong><a href="https://blog.csdn.net/yl_best/article/details/102593264">多维数组</a></strong></p>
<pre><code class="language-python">b02 = np.all(b1, axis=0, keepdims=True)      # 判断矩阵中 某个轴向上 所有元素是否都为True
print(&quot;np.all(b1, axis=0):\n&quot;, b02)
&gt;&gt;&gt;np.all(b1, axis=0):
[[[False True True True True True]
[ True True True True True True]
[ True True True True True True]]]

b03 = np.any(b1, axis=0, keepdims=True)      # 判断矩阵中 某个轴向上 是否有一个元素为True
print(&quot;np.any(b1, axis=0):\n&quot;, b03)
&gt;&gt;&gt;np.any(b1, axis=0):
[[[ True True True True True True]
[ True True True True True True]
[ True True True True True True]]]

b02 = np.all(b1 &lt; 15, axis=0, keepdims=True)      # 判断矩阵中 某个轴向上 所有元素是否都小于15
print(&quot;(np.all(b1 &lt; 15, axis=0):\n&quot;, b02)
&gt;&gt;&gt;(np.all(b1 &lt; 15, axis=0):
[[[False False False False False False]
[False False False False False False]
[False False False False False False]]]

b03 = np.any(b1 &lt; 15, axis=0, keepdims=True)      # 判断矩阵中 某个轴向上 是否有一个元素小于15。所有元素都大于15为False，有一个小于15即为True
print(&quot;np.any(b1 &lt; 15, axis=0):\n&quot;, b03)
&gt;&gt;&gt;np.any(b1 &lt; 15, axis=0):
[[[ True True True True True True]
[ True True True True True True]
[ True True True False False False]]] 

</code></pre>
<p><strong>功能：</strong></p>
<p>某矩阵A前n行是否全为零/前N+1行是否存在不为零的元素</p>
<pre><code class="language-python">if np.all(A[:n, :] == 0):
	print(&quot;A矩阵前n行所有元素均为零&quot;)

if np.any(A[:n+1，:] !=0 ):
	print(&quot;A矩阵前n+1行存在元素不为零&quot;)
</code></pre>
<h2 id="6-nppad的用法详解">6. np.pad()的用法详解</h2>
<p>https://blog.csdn.net/zenghaitao0128/article/details/78713663</p>
<h1 id="pandas">Pandas</h1>
<h2 id="1-字典创建-dataframe-长度不一致出错">1. 字典创建 DataFrame 长度不一致出错</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-python">import pandas as pd
d = {'A': [1, 2], 'C': [1, 2, 3, 4]}
data = pd.DataFrame(d)
&gt;&gt;&gt; ValueError: arrays must all be same length
</code></pre>
<p><strong>产生原因</strong></p>
<p>字典创建 DataFrame，键值对应的数组需等长。可以将键值数组转化转化为Series格式。</p>
<p><strong>解决方法</strong></p>
<pre><code class="language-python">import pandas as pd
a = {'A': [1, 2], 'C': [1, 2, 3, 4]}
b = dict([(k, pd.Series(v)) for k, v in d.items()]) # 列表转化为字典
c = pd.DataFrame(b) # 字典转化为Dataframe
c.to_excel('1.xlsx',index=False) # 序号从1开始

&gt;&gt;&gt;
    A  C
1  1.0  1
2  2.0  2
3  NaN  3
4  NaN  4
</code></pre>
<h2 id="2-pandas-to-excel-存储不同-sheet">2. Pandas to-excel() 存储不同 Sheet</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-python">import pandas as pd
a = dict.fromkeys(['a','b','c'],[])
b = dict.fromkeys(['a','b','c'],[])
num = 1 
for index in a.keys():
    a[index] = [num, num + 1 ,num + 2]
    for index in b.keys():
        b[index] = [num, num**2, num**3]
df1 = pd.DataFrame(df1)
df2 = pd.DataFrame(df2)
df1.to_excel('export_test.xls',sheet_name = 'sheet1')
df1.to_excel('export_test.xls',sheet_name = 'sheet2‘)
</code></pre>
<p>输出表格只有sheet2表，sheet1 表被覆盖。</p>
<p><strong>产生原因</strong></p>
<p>多次 to_excel() 输出，’export_test.xlsx‘ 被打开多次，写入只保留了最后一次。</p>
<p><strong>解决方法1 :</strong>   with open 方式使 ’export_test.xlsx‘ 被打开一次。</p>
<pre><code class="language-python">import pandas as pd
a = dict.fromkeys(['a','b','c'],[])
b = dict.fromkeys(['a','b','c'],[])
num = 1 
for index in a.keys():
    a[index] = [num, num + 1 ,num + 2]
    for index in b.keys():
        b[index] = [num, num**2, num**3]
df1 = pd.DataFrame(df1)
df2 = pd.DataFrame(df2)

with pd.ExcelWriter('export_test.xlsx') as write:
    df1.to_excel(write,sheet_name = 'sheet1')
    df2.to_excel(write,sheet_name = 'sheet2')
</code></pre>
<p><strong>解决方法2：</strong> 不用 with 方法，需在写入后上 write.save()</p>
<pre><code class="language-python">import pandas as pd
a = dict.fromkeys(['a','b','c'],[])
b = dict.fromkeys(['a','b','c'],[])
num = 1 
for index in a.keys():
    a[index] = [num, num + 1 ,num + 2]
    for index in b.keys():
        b[index] = [num, num**2, num**3]
df1 = pd.DataFrame(df1)
df2 = pd.DataFrame(df2)

write = pd.ExcelWriter('export_test.xlsx')
df1.to_excel(write,sheet_name = 'sheet1')
df2.to_excel(write,sheet_name = 'sheet2')
write.save()
</code></pre>
<p><strong>解决方法3：</strong> 补充<a href="https://www.thinbug.com/q/45251721">例子</a>利用字典循环输出不同 Sheet 表格</p>
<pre><code class="language-python">import pandas as pd

df1 = pd.DataFrame({'1_A': [1,2,3,4], '1_B': [5,4,6,5],
                    '1_C': [8,7,9,0], '1_D': [9,7,8,5], '1_E': [2,4,9,8]})
df2 = pd.DataFrame({'1_A': [5,4,1,3], '1_B': [55,2,3,4]})

setup_dict = {'Sheet_1': df1, 'Sheet_2': df2}

with pd.ExcelWriter('excel_file.xlsx',
                    engine='xlsxwriter') as writer:

    for ws_name, df_sheet in setup_dict.items():
        df_sheet.to_excel(writer, sheet_name=ws_name)
</code></pre>
<h2 id="3-pandas-浅拷贝和深拷贝-表格复制同步修改问题">3. Pandas 浅拷贝和深拷贝 - 表格复制同步修改问题</h2>
<p><strong>问题描述</strong></p>
<p>浅拷贝复制 pandas 数据，原数据修改会同时改变复制数据</p>
<pre><code class="language-python">import pandas as pd
a = pd.DataFrame({'id':[1,2,3,4,5],'fruit_name':[&quot;apple&quot;,&quot;orange&quot;,&quot;pineapple&quot;,&quot;banana&quot;,&quot;strawberry&quot;],'price':[7,8,9,10,11]})
b = a
a['price'] =[1, 1, 1, 1, 1]

&gt;&gt;&gt; b
   id  fruit_name  price
0   1       apple      1
1   2      orange      1
2   3   pineapple      1
3   4      banana      1
4   5  strawberry      1
</code></pre>
<p><strong>产生原因</strong></p>
<p>浅拷贝共用内存</p>
<p><strong>解决方法</strong></p>
<pre><code class="language-python"> b = a.copy()
 a['price'] =[2, 2, 2, 2, 2]

&gt;&gt;&gt; a
   id  fruit_name  price
0   1       apple      2
1   2      orange      2
2   3   pineapple      2
3   4      banana      2
4   5  strawberry      2
&gt;&gt;&gt; b
   id  fruit_name  price
0   1       apple      1
1   2      orange      1
2   3   pineapple      1
3   4      banana      1
4   5  strawberry      1
 
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/nameix/article/details/54341949">内置函数+内置变量+内置模块</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 添加配置文件（.ini, .py, .json, etc）]]></title>
        <id>https://numantia.github.io/post/python-configuration-method/</id>
        <link href="https://numantia.github.io/post/python-configuration-method/">
        </link>
        <updated>2021-05-25T06:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%BF%85%E8%A6%81%E6%80%A7">配置文件必要性</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83">常用配置文件比较</a>
<ul>
<li><a href="#1-ini-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1. ini 配置文件</a></li>
<li><a href="#2-json-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">2. json 配置文件</a></li>
<li><a href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB">3.  初始化类</a></li>
</ul>
</li>
</ul>
</p>
<p>[TOC]</p>
<h1 id="配置文件必要性">配置文件必要性</h1>
<ol>
<li>集中管理，统一修改，降低修改难度，避免修改不全面</li>
<li>代码和参数分离，方便不同模块代码中重复调用，保持核心代码整洁</li>
</ol>
<h1 id="常用配置文件比较">常用配置文件比较</h1>
<p>配置文件复杂度比 ini &lt; json ≈ toml &lt; yaml</p>
<table>
<thead>
<tr>
<th>格式类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>config.ini</td>
<td>通用格式，格式简单</td>
<td>不适合存储大量数据</td>
</tr>
<tr>
<td>config.json</td>
<td>通用格式，可嵌套，适合存放大量的<strong>结构化配置</strong>或者本地数据</td>
<td><strong>嵌套过深</strong>的问题，容易导致出错；语法标准严格限制，无法在当中<strong>写注释</strong></td>
</tr>
<tr>
<td>config.py / setting.py</td>
<td>在python工程中方便通过import方式导入</td>
<td>不利于<strong>非 Python 的平台</strong>进行配置文件共享</td>
</tr>
</tbody>
</table>
<h2 id="1-ini-配置文件">1. ini 配置文件</h2>
<p>使用 “ import configparser ”导入configparser模块，即可实现配置文件的写入、更新、删除、读取等操作。</p>
<p><strong>读</strong>  :</p>
<p><code>config.get(&quot;section&quot;, &quot;option&quot;)</code>  # 获取指定section下的options</p>
<p><code>config.getint(&quot;section&quot;, &quot;option&quot;)</code> # 将获取到值转换为int型</p>
<p><code>config.getboolean(&quot;section&quot;, &quot;option&quot;)</code> # 将获取到值转换为bool型</p>
<p><code>config.getfloat(&quot;section&quot;, &quot;option&quot;)</code>  # 将获取到值转换为浮点型</p>
<p><strong>更新：</strong></p>
<p><code>config.set(&quot;section_mod&quot;, &quot;option&quot;, &quot;option_value&quot;)</code> # 修改section_mod的option</p>
<p><code>config.add_section(&quot;section_add&quot;)</code> # 添加section节点</p>
<p><code>config.set(&quot;section_add&quot;, &quot;option&quot;, &quot;option_value&quot;)</code> # 设置指定section_add的options</p>
<p><strong>检查：</strong></p>
<p><code>config.options('section')</code>  # 获取指定section 的options即该节点的所有键</p>
<p><code>config.has_section(&quot;section&quot;)</code># 是否存在该section</p>
<p><code>config.has_option(&quot;section&quot;, &quot;option&quot;)</code>  # 是否存在该option</p>
<p><strong>删除：</strong></p>
<p><code>config.remove_section(&quot;section_rmv&quot;)</code> # 整个section_rmv下的所有内容都将删除</p>
<p><code>config.remove_option(&quot;section_rmv&quot;, 'option')</code> # 删除section_rmv下的指定option</p>
<p><strong>保存：</strong></p>
<p><code>config.write(open(&quot;Config&quot;, &quot;w&quot;))</code> # 保存config</p>
<p><strong>注意事项</strong></p>
<ol>
<li>
<p>读取都是字符串，无需在配置的时候写成字符串</p>
</li>
<li>
<p>读取字符串不区分大小写</p>
</li>
</ol>
<p>参考链接 1. <a href="https://zhuanlan.zhihu.com/p/59479898">python中配置文件的使用方法</a></p>
<h2 id="2-json-配置文件">2. json 配置文件</h2>
<pre><code class="language-python">&gt;&gt;&gt; import json
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; with open('/Users/Bobot/db.json') as j:
...   cfg = json.load(j)['localdb']
... 
&gt;&gt;&gt; pprint(cfg)
{'database': 'mysql',
 'host': '127.0.0.1',
 'password': '123456',
 'port': 3306,
 'user': 'root'}
</code></pre>
<p>使用json.load()读取json文件，读入的词典，无法直接用键值当做变量，常规需要 <code>database = cfg ['database']</code>  赋值方式来配置变量，若变量增多，配置过程会非常繁琐。通过 <code>globals().update(config)</code>  可以实现字典的变量访问，<code>globals()</code>获得（模块级）全局变量所组成的字典，修改该字典等同修改全局变量，所以通过 <code>.update(config)</code>可以将 <code>config</code> 字典内容转为变量<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<pre><code class="language-python">a_dict = {&quot;key&quot;: &quot;value&quot;}
globals().update(a_dict)
print(key)
</code></pre>
<h2 id="3-初始化类">3.  初始化类</h2>
<p><strong>config.ini</strong></p>
<pre><code class="language-ini">[first_section]
option1 = 1
option2 = 0
option3 = 3.4
</code></pre>
<p><strong>config.json</strong></p>
<pre><code class="language-json">{
    &quot;localdb&quot;:{
        &quot;host&quot;: &quot;127.0.0.1&quot;,
        &quot;user&quot;: &quot;root&quot;,
        &quot;password&quot;: &quot;123456&quot;,
        &quot;port&quot;: 3306,
        &quot;database&quot;: &quot;mysql&quot;
    }
}
</code></pre>
<p><strong>initDemo()</strong></p>
<pre><code class="language-python">import configparser
import json

class initDemo():
    def __init__(self,fp1,fp2):
        self.fp1 = fp1 # .json 文件路径
        self.fp2 = fp2 # .ini 文件路径

    def read_json_config(self):
        &quot;&quot;&quot;&quot;读取json配置文件&quot;&quot;&quot;
        with open(self.fp1) as json_file:
            config = json.load(json_file)['localdb']
        return config

    def read_ini_config(self):
        
        &quot;&quot;&quot;&quot;读取ini配置文件&quot;&quot;&quot;
        config = configparser.ConfigParser()
        config.read(self.fp2, encoding=&quot;utf-8&quot;)

        first_section_items = dict(config.items(&quot;first_section&quot;))
        all_keys = config.options('first_section') # 只能识别小写，获取指定section 的options即该节点的所有键
        
        item1 = config.getint('first_section','item1') # 将获取到值转换为int型
        itme2 = config.getboolean('first_section','item2') # 将获取到值转换为bool型
        item3 = config.getfloat('first_section','item3') # 将获取到值转换为浮点型
        return 

    def update_json_config(self, config):
        &quot;&quot;&quot;&quot;更新配置文件&quot;&quot;&quot;
        with open(self.fp1, 'w') as json_file:
            json.dump(config, json_file)
        return None
</code></pre>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><ol>
<li><a href="https://blog.csdn.net/modabao/article/details/89193990">Python3.用json作为配置文件</a></li>
</ol>
 <a href="#fnref1" class="footnote-backref">↩︎</a></li>
</ol>
</section>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://numantia.github.io</id>
    <title>云杉的速记</title>
    <updated>2021-06-29T03:57:27.308Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://numantia.github.io"/>
    <link rel="self" href="https://numantia.github.io/atom.xml"/>
    <subtitle>开放和共享思考，力争简化复杂，复杂天真</subtitle>
    <logo>https://numantia.github.io/images/avatar.png</logo>
    <icon>https://numantia.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 云杉的速记</rights>
    <entry>
        <title type="html"><![CDATA[Python 代码检查工具 pylint]]></title>
        <id>https://numantia.github.io/post/python-modules-pylint/</id>
        <link href="https://numantia.github.io/post/python-modules-pylint/">
        </link>
        <updated>2021-06-29T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE">安装和配置</a>
<ul>
<li><a href="#1-%E5%AE%89%E8%A3%85">1. 安装</a></li>
<li><a href="#2-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85">2. 检查是否安装</a></li>
<li><a href="#3-%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">3. 生成默认配置文件</a></li>
<li><a href="#4-%E6%9F%A5%E7%9C%8B%E5%B8%AE%E5%8A%A9%E6%96%87%E4%BB%B6">4. 查看帮助文件</a></li>
</ul>
</li>
<li><a href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B">快速上手</a>
<ul>
<li><a href="#1-%E6%B5%8B%E8%AF%95%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6">1. 测试单个文件</a></li>
<li><a href="#2-%E6%B5%8B%E8%AF%95%E6%95%B4%E4%B8%AA%E5%B7%A5%E7%A8%8B">2. 测试整个工程</a></li>
<li><a href="#3-%E7%94%9F%E6%88%90%E6%8A%A5%E5%91%8A%E6%A0%B7%E4%BE%8B">3. 生成报告样例</a></li>
<li><a href="#4-%E6%A0%B9%E6%8D%AE%E6%84%8F%E8%A7%81%E4%BF%AE%E6%94%B9">4. 根据意见修改</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86">进阶知识</a>
<ul>
<li><a href="#1-%E5%90%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0">1. 各异常处理方法（持续更新 ...）</a></li>
<li><a href="#2-%E5%9C%A8%E4%B8%80%E4%B8%AApython%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B0%83%E7%94%A8-pylint">2. 在一个Python程序中调用 pylint</a></li>
<li><a href="#3-%E9%85%8D%E7%BD%AE%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C">3. 配置高级操作</a></li>
<li><a href="#4-%E5%B1%80%E9%83%A8%E5%85%B3%E9%97%AD%E6%9F%90%E5%91%8A%E8%AD%A6%E7%B1%BB%E5%9E%8B">4. 局部关闭某告警类型</a></li>
</ul>
</li>
</ul>
</p>
<p>[toc]</p>
<h1 id="安装和配置">安装和配置</h1>
<h2 id="1-安装">1. 安装</h2>
<pre><code class="language-powershell">&gt; pip install pylint
</code></pre>
<p>若下载遇到问题，可以参考<a href="https://numantia.github.io/post/pip-software-source-management/">此篇</a>文章，更改软件源。</p>
<h2 id="2-检查是否安装">2. 检查是否安装</h2>
<pre><code class="language-powershell">&gt; pylint --version
pylint 2.8.3
astroid 2.5.6
Python 3.7.9
</code></pre>
<h2 id="3-生成默认配置文件">3. 生成默认配置文件</h2>
<pre><code>&gt;pylint --persistent=n --generate-rcfile &gt; pylint.conf
No config file found, using default configuration
</code></pre>
<p>会在当前目录下，生成 pylint.conf 文件，该文件中的配置项都是 <em>pylint</em> 的默认配置。</p>
<h2 id="4-查看帮助文件">4. 查看帮助文件</h2>
<pre><code>&gt; pylint --help
&gt; pylint --long-help (查看更多帮助)
</code></pre>
<h1 id="快速上手">快速上手</h1>
<p>使用 simplecaesar.py python 脚本作为测试文件</p>
<pre><code class="language-python"> 1  #!/usr/bin/env python3
 2
 3  import string;
 4
 5  shift = 3
 6  choice = input(&quot;would you like to encode or decode?&quot;)
 7  word = input(&quot;Please enter text&quot;)
 8  letters = string.ascii_letters + string.punctuation + string.digits
 9  encoded = ''
10  if choice == &quot;encode&quot;:
11      for letter in word:
12          if letter == ' ':
13              encoded = encoded + ' '
14          else:
15              x = letters.index(letter) + shift
16              encoded = encoded + letters[x]
17  if choice == &quot;decode&quot;:
18      for letter in word:
19          if letter == ' ':
20              encoded = encoded + ' '
21          else:
22              x = letters.index(letter) - shift
23              encoded = encoded + letters[x]
24
25  print(encoded)
</code></pre>
<h2 id="1-测试单个文件">1. 测试单个文件</h2>
<pre><code class="language-powershell">&gt;pylint --rcfile=pylint.conf simplecaesar.py

************* Module simplecaesar
C:  1, 0: Missing module docstring (missing-docstring)
W: 14,12: Unused import django (unused-import)
</code></pre>
<p>每次命令添加 <code>--rcfile</code> 选项会比较繁琐，重命名<code>pylint.conf</code>为<code>.pylintrc</code>，即不需要每次执行都带上<code>--rcfile</code>参数了。</p>
<h2 id="2-测试整个工程">2. 测试整个工程</h2>
<pre><code>&gt; pylint package_name(package_name为包名称,根目录下需添加init.py)
</code></pre>
<h2 id="3-生成报告样例">3. 生成报告样例</h2>
<pre><code>&gt; pylint simplecaesar.py
************* Module simplecaesar
simplecaesar.py【模块名称】:3:0:【行号：列号】 W0301【W 代表检查级别， 303 为编号】: Unnecessary semicolon【详细消息】 (unnecessary-semicolon)【问题消息ID号, &lt;msg-id&gt;】
simplecaesar.py:1:0: C0114: Missing module docstring (missing-module-docstring)
simplecaesar.py:5:0: C0103: Constant name &quot;shift&quot; doesn't conform to UPPER_CASE naming style (invalid-name)
simplecaesar.py:9:0: C0103: Constant name &quot;encoded&quot; doesn't conform to UPPER_CASE naming style (invalid-name)
simplecaesar.py:13:12: C0103: Constant name &quot;encoded&quot; doesn't conform to UPPER_CASE naming style (invalid-name)

-----------------------------------
Your code has been rated at 7.37/10
</code></pre>
<p>所有告警类别</p>
<pre><code>Output:
   Using the default text output, the message format is :
  MESSAGE_TYPE: LINE_NUM:[OBJECT:] MESSAGE
  There are 5 kind of message types :
  * (C) convention, for programming standard violation [不符合编程规范]
  * (R) refactor, for bad code smell [需重构]
  * (W) warning, for python specific problems [警告]
  * (E) error, for probable bugs in the code [错误]
  * (F) fatal, if an error occurred which prevented pylint from doing
  further processing.[致命错误]
</code></pre>
<p>可以通过 <code>pylint --help-msg &lt;msg-id&gt;</code> 获取更多告警帮助信息</p>
<pre><code>&gt;pylint --help-msg trailing-whitespace
:trailing-whitespace (C0303): *Trailing whitespace*
  Used when there is whitespace between the end of a line and the newline. This
  message belongs to the format checker.
</code></pre>
<h2 id="4-根据意见修改">4. 根据意见修改</h2>
<p>根据意见，在第二行增加文档字符串，去除第三行；</p>
<pre><code class="language-python"> 1  #!/usr/bin/env python3
 2  &quot;&quot;&quot;This script prompts a user to enter a message to encode or decode
 3  using a classic Caesar shift substitution (3 letter shift)&quot;&quot;&quot;
 4
 5  import string
 6
 7  shift = 3
 8  choice = input(&quot;would you like to encode or decode?&quot;)
 9  word = input(&quot;Please enter text&quot;)
10  letters = string.ascii_letters + string.punctuation + string.digits
11  encoded = ''
12  if choice == &quot;encode&quot;:
13      for letter in word:
14          if letter == ' ':
15              encoded = encoded + ' '
16          else:
17              x = letters.index(letter) + shift
18              encoded = encoded + letters[x]
19  if choice == &quot;decode&quot;:
20      for letter in word:
21          if letter == ' ':
22              encoded = encoded + ' '
23          else:
24              x = letters.index(letter) - shift
25              encoded = encoded + letters[x]
26
27  print(encoded)
</code></pre>
<pre><code class="language-powershell">robertk01 Desktop$ pylint simplecaesar.py
************* Module simplecaesar
simplecaesar.py:7:0: C0103: Constant name &quot;shift&quot; doesn't conform to UPPER_CASE naming style (invalid-name)
simplecaesar.py:11:0: C0103: Constant name &quot;encoded&quot; doesn't conform to UPPER_CASE naming style (invalid-name)
simplecaesar.py:15:12: C0103: Constant name &quot;encoded&quot; doesn't conform to UPPER_CASE naming style (invalid-name)

------------------------------------------------------------------
Your code has been rated at 8.42/10 (previous run: 7.37/10, +1.05)
</code></pre>
<p>比起上一版程序，评分提高 1.05，只剩下 <code>invalid-name</code> 信息。</p>
<p>这是因为 Pylint 中遵从 <a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a>  对象命名规范，使用大写，小写以及分隔符来定义变量、函数和类名，Pylint 通过正则表达式验证， <code>(([A-Z_][A-Z1-9_]*)|(__.*__))$</code>。例子中，常数变量应该采用全大写，这和 Pylint 缺省的规范不一致。当然也可以通过自定义是常数为全小数 <code>[a-z_][a-z0-9_]{2,30}$</code>  。</p>
<pre><code class="language-powershell">&gt; pylint --const-rgx='[a-z_][a-z0-9_]{2,30}$' simplecaesar.py
-------------------------------------------------------------------
Your code has been rated at 10.00/10 (previous run: 8.42/10, +1.58)
</code></pre>
<h1 id="进阶知识">进阶知识</h1>
<h2 id="1-各异常处理方法持续更新">1. 各异常处理方法（持续更新 ...）</h2>
<h2 id="2-在一个python程序中调用-pylint">2. 在一个Python程序中调用 pylint</h2>
<p>**方法1：**输出terminal</p>
<pre><code class="language-python">import pylint.lint
pylint_opts = ['--version']
pylint.lint.Run(pylint_opts)
</code></pre>
<p><strong>方法2：</strong> 静默运行</p>
<pre><code class="language-python">from pylint import epylint as lint
(pylint_stdout, pylint_stderr) = lint.py_run('module_name.py', return_std=True)

# 可在py_run() 第一个参数位置添加 pylint option
from pylint import epylint as lint
(pylint_stdout, pylint_stderr) = lint.py_run('module_name.py --disable C0114', return_std=True)
</code></pre>
<p>消息模板选项 <code>--msg-template=&quot;{path}:{line}: {category} ({msg_id}, {symbol}, {obj}) {msg}&quot;</code> 以及<code>--reports=n</code> 是<code>epylint</code> 模块隐式定义.</p>
<h2 id="3-配置高级操作">3. 配置高级操作</h2>
<p>使用[生成默认配置文件](#3. 生成默认配置文件)操作可以简化繁琐的配置过程，快速定义默认的全面的配置选项。你有两种方式使用配置文件，第一种使用<code>--rcfile</code>参数，第二种 pylint 按如下顺序搜索配置文件，选择第一个出现的。</p>
<ol>
<li><code>pylintrc</code> in the current working directory</li>
<li><code>.pylintrc</code> in the current working directory</li>
<li><code>pyproject.toml</code> in the current working directory, providing it has at least one <code>tool.pylint.</code> section.</li>
<li><code>setup.cfg</code> in the current working directory, providing it has at least one <code>pylint.</code> section</li>
<li>If the current working directory is in a Python package, Pylint searches up the hierarchy of Python packages until it finds a <code>pylintrc</code> file. This allows you to specify coding standards on a module-by-module basis. Of course, a directory is judged to be a Python package if it contains an <code>__init__.py</code> file.</li>
<li>The file named by environment variable <code>PYLINTRC</code></li>
</ol>
<p>当然你可以在基础的配置上，手动调整一些配置，如下为常见的<a href="https://pylint.readthedocs.io/en/latest/user_guide/output.html">配置</a>:</p>
<p><code>--ignore=&lt;file[,file...]&gt;</code> 	Files or directories to be skipped. They should be base names, not paths.</p>
<p><code>--output=&lt;file&gt;</code>   Specify an output file， 输出到本地文件</p>
<p><code>--output-format=&lt;format&gt;</code>	Select output format (text, json, custom).  <format> a comma-separated list of formats（多个格式，好像不能输出）. Possible values are: json, parseable, colorized and msvs (visual studio)</p>
<p><code>--msg-template=&lt;template&gt;</code> 	Modify text output message template. the default format:{path}:{line}:{column}: {msg_id}: {msg} ({symbol}) The format string uses the <a href="https://docs.python.org/2/library/string.html#formatstrings">Python new format syntax</a> and the following fields are available :</p>
<ul>
<li>[path] relative path to the file</li>
<li>[abspath] absolute path to the file</li>
<li>[line] line number</li>
<li>[column] column number</li>
<li>[module] module name</li>
<li>[obj] object within the module (if any)</li>
<li>[msg] text of the message</li>
<li>[msg_id] id the message code (eg. I0011)</li>
<li>[symbol] symbolic name of the message (eg. locally-disabled)</li>
<li>[C] one letter indication of the message category</li>
<li>[category] fullname of the message category</li>
</ul>
<p><code>--list-msgs</code>	Generate pylint's messages.</p>
<p><code>--list-msgs-enabled</code>	Display a list of what messages are enabled and disabled with the given configuration.</p>
<p><code>--full-documentation</code>	Generate pylint's full documentation, in reST format.</p>
<p>常用例子</p>
<pre><code>pylint --output=pylint_test.json --output-format=json test.py
pylint --msg-template='{msg_id}:{line:3d},{column}: {obj}: {msg}'

Visual Studio compatible format (former 'msvs' output format):{path}({line}): [{msg_id}{obj}] {msg}

Parseable (Emacs and all, former 'parseable' output format) format: {path}:{line}: [{msg_id}({symbol}), {obj}] {msg}
</code></pre>
<h2 id="4-局部关闭某告警类型">4. 局部关闭某告警类型</h2>
<pre><code class="language-python">&quot;&quot;&quot;pylint option block-disable&quot;&quot;&quot;

__revision__ = None

class Foo(object):
    &quot;&quot;&quot;block-disable test&quot;&quot;&quot;

    def __init__(self):
        pass

    def meth1(self, arg):
        &quot;&quot;&quot;this issues a message&quot;&quot;&quot;
        print(self)

    def meth2(self, arg):
        &quot;&quot;&quot;and this one not 关闭一个block的unused-argument错误&quot;&quot;&quot;
        # pylint: disable=unused-argument
        print(self\
              + &quot;foo&quot;)

    def meth3(self):
        &quot;&quot;&quot;test one line disabling 关闭一行&quot;&quot;&quot;
        # no error
        print(self.bla) # pylint: disable=no-member
        # error
        print(self.blop)

    def meth4(self):
        &quot;&quot;&quot;test re-enabling 重使能&quot;&quot;&quot;
        # pylint: disable=no-member
        # no error
        print(self.bla)
        print(self.blop)
        # pylint: enable=no-member
        # error
        print(self.blip)

    def meth5(self):
        &quot;&quot;&quot;test IF sub-block re-enabling&quot;&quot;&quot;
        # pylint: disable=no-member
        # no error
        print(self.bla)
        if self.blop:
            # pylint: enable=no-member
            # error
            print(self.blip)
        else:
            # no error
            print(self.blip)
        # no error
        print(self.blip)

    def meth6(self):
        &quot;&quot;&quot;test TRY/EXCEPT sub-block re-enabling&quot;&quot;&quot;
        # pylint: disable=no-member
        # no error
        print(self.bla)
        try:
            # pylint: enable=no-member
            # error
            print(self.blip)
        except UndefinedName: # pylint: disable=undefined-variable
            # no error
            print(self.blip)
        # no error
        print(self.blip)

    def meth7(self):
        &quot;&quot;&quot;test one line block opening disabling&quot;&quot;&quot;
        if self.blop: # pylint: disable=no-member
            # error
            print(self.blip)
        else:
            # error
            print(self.blip)
        # error
        print(self.blip)

    def meth8(self):
        &quot;&quot;&quot;test late disabling&quot;&quot;&quot;
        # error
        print(self.blip)
        # pylint: disable=no-member
        # no error
        print(self.bla)
        print(self.blop)
</code></pre>
<ol>
<li>
<p><a href="https://pylint.readthedocs.io/en/latest/index.html">pylint 官网</a></p>
</li>
<li>
<p><a href="https://pylint.readthedocs.io/en/latest/faq.html#faq">Pylint-FAQs</a></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单使用 Jupyter Notebook：案例+快速查表]]></title>
        <id>https://numantia.github.io/post/introduction-to-jupyter/</id>
        <link href="https://numantia.github.io/post/introduction-to-jupyter/">
        </link>
        <updated>2021-06-28T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><strong>案例1：在Anaconda虚拟环境运行Jupyter Notebook</strong></p>
<ol>
<li>创建名称为 myenv 的虚拟环境，并指定 python 版本，在虚拟环境下安装需求模块。</li>
</ol>
<pre><code class="language-python">conda create -n myenv python=3.5
# conda create --name myenv
pip install tensorflow numpy scipy -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
</code></pre>
<ol start="2">
<li>激活新建的虚拟环境，此时直接运行 jupyter notebook，并<strong>未使用运行环境的 Python 内核</strong>，导致 kernel error。此时装在<strong>虚拟环境中的模块</strong>也无法使用。其他环境操作，可参考<a href="https://www.notion.so/yuanchengwei/Python-Tutorials-c7715db2aaef4f858dfcc0495ce550c6#13c747ee79eb4821aea70c33f4673408">Conda Cheet Sheet</a></li>
</ol>
<pre><code class="language-python">conda activate myenv
jupyter notebook
</code></pre>
<img src="../post-images/kernel-error.png" alt="kernel-error" style="zoom: 80%;" />
<ol start="3">
<li>解决方法1：安装 nb-conda 插件解决问题，就可以在 jupyter notebook 切换虚拟环境的内核，并使用内部安装的模块(推荐)。</li>
</ol>
<pre><code class="language-python">conda install nb_conda
</code></pre>
<ol start="4">
<li>解决方法2：激活环境后，安装 ipykernel 插件解决问题</li>
</ol>
<pre><code>conda activate myenv
conda install ipykernel
python -m ipykernel install --name myenv --display-name myenvkernel
</code></pre>
<ol start="5">
<li>jupyter notebook 中可切换虚拟环境的内核，问题解决</li>
</ol>
<p><strong>说明<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</strong></p>
<p>打开Anaconda Prompt,输入 jupyter kernelspec list 查看安装的内核和位置，上面两个解决方法都是在 .../jupyter/kernels/目录下创建一个命名为**{对应名称}<strong>的文件夹，文件夹下放一个</strong>kernel.json**文件。</p>
<pre><code class="language-json">{
 &quot;argv&quot;: [
  &quot;C:\\Users\\yuanchengwei\\AppData\\Local\\Programs\\Python\\Python38-32\\python.exe&quot;,
  &quot;-m&quot;,
  &quot;ipykernel_launcher&quot;,
  &quot;-f&quot;,
  &quot;{connection_file}&quot;
 ],
 &quot;display_name&quot;: &quot;Python 3&quot;,
 &quot;language&quot;: &quot;python&quot;
}
</code></pre>
<p>如果我们在对应的/kernels/目录下，新建一个文件夹，再新建一个kernel.json，把地址设置为'./anaconda3/envs/myenv/bin/python'，就可以用到虚拟环境qq下的python了。</p>
<p>案例 2：md 转化为 ipynb</p>
<pre><code>## jupyter notebook 安装
pip3 install jupytext --upgrade

## jupyterlab 安装
jupyter labextension install jupyterlab-jupytext --minimize=False

## 目录下所有md文件转化为ipynb
jupytext --set-formats ipynb,md *.md
</code></pre>
<pre><code>运行shell命令
!ls *.csv
nba_2016.csv             titanic.csv
pixar_movies.csv         whitehouse_employees.csv

!pip install numpy
!pip list | grep pandas
Requirement already satisfied (use --upgrade to upgrade): numpy in /Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages
pandas (0.18.1)
</code></pre>
<pre><code>Latex 公式
$$ P(A \mid B) = \frac{P(B \mid A) \, P(A)}{P(B)} $$
</code></pre>
<p><a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html">Magic command</a></p>
<pre><code class="language-python">line magics  % 对单行有效, Automagic is ON, % prefix IS NOT needed for line magics.
cell magics  %% 对整个cells有效

%lsmagic

Available line magics:
%alias  %alias_magic  %autocall  %automagic  %autosave  %bookmark  %cat  %cd  %clear  %colors  %config  %connect_info  %cp  %debug  %dhist  %dirs  %doctest_mode  %ed  %edit  %env  %gui  %hist  %history  %killbgscripts  %ldir  %less  %lf  %lk  %ll  %load  %load_ext  %loadpy  %logoff  %logon  %logstart  %logstate  %logstop  %ls  %lsmagic  %lx  %macro  %magic  %man  %matplotlib  %mkdir  %more  %mv  %notebook  %page  %pastebin  %pdb  %pdef  %pdoc  %pfile  %pinfo  %pinfo2  %popd  %pprint  %precision  %profile  %prun  %psearch  %psource  %pushd  %pwd  %pycat  %pylab  %qtconsole  %quickref  %recall  %rehashx  %reload_ext  %rep  %rerun  %reset  %reset_selective  %rm  %rmdir  %run  %save  %sc  %set_env  %store  %sx  %system  %tb  %time  %timeit  %unalias  %unload_ext  %who  %who_ls  %whos  %xdel  %xmode

例子
% run
% who
% timeit [i for i in range(1000)]
% pwd
% ls
% cd
</code></pre>
<pre><code class="language-bash">Available cell magics:
%%!  %%HTML  %%SVG  %%bash  %%capture  %%debug  %%file  %%html  %%javascript  %%js  %%latex  %%perl  %%prun  %%pypy  %%python  %%python2  %%python3  %%ruby  %%script  %%sh  %%svg  %%sx  %%system  %%time  %%timeit  %%writefile

例子
%%bash
for i in {1..5}
do
  echo &quot;i is $i&quot;
done
i is 1
i is 2
i is 3
i is 4
i is 5
</code></pre>
<p>键盘快捷键</p>
<p>https://zhuanlan.zhihu.com/p/32600329</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/w55100/article/details/88925697">使用anaconda虚拟环境运行Jupyter Notebook详解</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VS Code 快捷键和用法]]></title>
        <id>https://numantia.github.io/post/vscode-keyboard-shorcut/</id>
        <link href="https://numantia.github.io/post/vscode-keyboard-shorcut/">
        </link>
        <updated>2021-06-25T04:00:44.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%BC%96%E8%BE%91-basic-editing">基础编辑 Basic editing</a></li>
<li><a href="#%E5%AF%BC%E8%88%AA-navigation">导航 Navigation</a></li>
<li><a href="#%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2-search-and-replace">搜索和替换 Search and replace</a></li>
<li><a href="#%E5%A4%9A%E5%85%89%E6%A0%87%E5%92%8C%E9%80%89%E6%8B%A9-multi-cursor-and-selection">多光标和选择 Multi-cursor and selection</a></li>
<li><a href="#%E4%B8%B0%E5%AF%8C%E7%9A%84%E8%AF%AD%E8%A8%80%E7%BC%96%E8%BE%91-rich-languages-editing">丰富的语言编辑 Rich languages editing</a></li>
<li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8%E7%AE%A1%E7%90%86-editor-management">编辑器管理 Editor management</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-file-management">文件管理 File management</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA-display">显示 Display</a></li>
<li><a href="#%E8%B0%83%E8%AF%95-debug">调试 Debug</a></li>
<li><a href="#%E9%9B%86%E6%88%90%E7%BB%88%E7%AB%AF-integrated-terminal">集成终端 Integrated terminal</a></li>
</ul>
</li>
</ul>
</p>
<p>本篇文章用作个人快捷键备忘，不求全面，若您本意是想找到特定快捷键，可以点击 <code>菜单栏 &gt; help &gt; Keyboard Shortcuts Reference</code> , Window常用快捷键可以点击该<a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">链接</a>，若想查看中文版本，该篇<a href="https://blog.csdn.net/p358278505/article/details/74221214">博文</a>有详细说明。</p>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl + Shift + P，F1</td>
<td style="text-align:left">显示命令面板 Show Command Palette</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + P</td>
<td style="text-align:left">快速打开 Quick Open</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + N</td>
<td style="text-align:left">新窗口/实例 New window/instance</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + W</td>
<td style="text-align:left">关闭窗口/实例 Close window/instance</td>
</tr>
</tbody>
</table>
<h2 id="基础编辑-basic-editing">基础编辑 Basic editing</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl+X</td>
<td style="text-align:left">剪切行（空选定） Cut line (empty selection)</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+C</td>
<td style="text-align:left">复制行（空选定）Copy line (empty selection)</td>
</tr>
<tr>
<td style="text-align:left">Shift+Alt + ↓ / ↑</td>
<td style="text-align:left">向上/向下复制行 Copy line up/down</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+K</td>
<td style="text-align:left">删除行 Delete line</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Enter</td>
<td style="text-align:left">在下面插入行 Insert line below</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+Enter</td>
<td style="text-align:left">在上面插入行 Insert line above</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+[</td>
<td style="text-align:left">折叠（折叠）区域 Fold (collapse) region</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+]</td>
<td style="text-align:left">展开（未折叠）区域 Unfold (uncollapse) region</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K Ctrl+[</td>
<td style="text-align:left">折叠（未折叠）所有子区域 Fold (collapse) all subregions</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K Ctrl+]</td>
<td style="text-align:left">展开（未折叠）所有子区域 Unfold (uncollapse) all subregions</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K Ctrl+0</td>
<td style="text-align:left">折叠（折叠）所有区域 Fold (collapse) all regions</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K Ctrl+J</td>
<td style="text-align:left">展开（未折叠）所有区域 Unfold (uncollapse) all regions</td>
</tr>
</tbody>
</table>
<h2 id="导航-navigation">导航 Navigation</h2>
<h2 id="搜索和替换-search-and-replace">搜索和替换 Search and replace</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl + F</td>
<td style="text-align:left">查找 Find</td>
</tr>
<tr>
<td style="text-align:left">Ctrl + H</td>
<td style="text-align:left">替换 Replace</td>
</tr>
<tr>
<td style="text-align:left">F3 / Shift + F3</td>
<td style="text-align:left">查找下一个/上一个 Find next/previous</td>
</tr>
<tr>
<td style="text-align:left">Alt + Enter</td>
<td style="text-align:left">选择查找匹配的所有出现 Select all occurences of Find match</td>
</tr>
</tbody>
</table>
<h2 id="多光标和选择-multi-cursor-and-selection">多光标和选择 Multi-cursor and selection</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Alt +单击</td>
<td style="text-align:left">插入光标 Insert cursor</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + I</td>
<td style="text-align:left">选择当前行 Select current line</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + Shift + L</td>
<td style="text-align:left">选择当前选择的所有出现 Select all occurrences of current selection</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Ctrl + F2</td>
<td style="text-align:left">选择当前字的所有出现 Select all occurrences of current word</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Shift + Alt + →</td>
<td style="text-align:left">展开选择 Expand selection</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Shift + Alt + ←</td>
<td style="text-align:left">缩小选择 Shrink selection</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="丰富的语言编辑-rich-languages-editing">丰富的语言编辑 Rich languages editing</h2>
<h2 id="编辑器管理-editor-management">编辑器管理 Editor management</h2>
<h2 id="文件管理-file-management">文件管理 File management</h2>
<h2 id="显示-display">显示 Display</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">F11</td>
<td style="text-align:left">切换全屏 Toggle full screen</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+V</td>
<td style="text-align:left">切换Markdown预览 Toggle Markdown preview</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K V</td>
<td style="text-align:left">从旁边打开Markdown预览 Open Markdown preview to the side</td>
</tr>
</tbody>
</table>
<h2 id="调试-debug">调试 Debug</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">F9</td>
<td style="text-align:left">切换断点 Toggle breakpoint</td>
</tr>
<tr>
<td style="text-align:left">F5</td>
<td style="text-align:left">开始/继续 Start/Continue</td>
</tr>
<tr>
<td style="text-align:left">Shift+F5</td>
<td style="text-align:left">停止 Stop</td>
</tr>
<tr>
<td style="text-align:left">F11 / Shift+F11</td>
<td style="text-align:left">下一步/上一步 Step into/out</td>
</tr>
<tr>
<td style="text-align:left">F10</td>
<td style="text-align:left">跳过 Step over</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+K Ctrl+I</td>
<td style="text-align:left">显示悬停 Show hover</td>
</tr>
</tbody>
</table>
<h2 id="集成终端-integrated-terminal">集成终端 Integrated terminal</h2>
<table>
<thead>
<tr>
<th style="text-align:left">按 Press</th>
<th style="text-align:left">功能 Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ctrl+`</td>
<td style="text-align:left">显示集成终端 Show integrated terminal</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+C</td>
<td style="text-align:left">复制选定 Copy selection</td>
</tr>
<tr>
<td style="text-align:left">Ctrl+Shift+V</td>
<td style="text-align:left">粘贴到活动端子 Paste into active terminal</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 数据类型之 dict（讲解+案例+FAQs）]]></title>
        <id>https://numantia.github.io/post/python-dtype-dict/</id>
        <link href="https://numantia.github.io/post/python-dtype-dict/">
        </link>
        <updated>2021-06-24T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#faqs">FAQs</a>
<ul>
<li><a href="#1-%E4%B8%80%E6%AC%A1%E8%8E%B7%E5%8F%96%E5%AD%97%E5%85%B8%E5%A4%9A%E4%B8%AA%E5%80%BC">1. 一次获取字典多个值</a></li>
<li><a href="#2-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E5%AD%97%E5%85%B8">2. 函数返回值为字典</a></li>
</ul>
</li>
<li><a href="#introduction-to-dictionary">Introduction to Dictionary</a>
<ul>
<li><a href="#definition">Definition:</a></li>
<li><a href="#benifits">Benifits:</a></li>
<li><a href="#key-points">Key points:</a>
<ul>
<li><a href="#inspect">Inspect</a></li>
<li><a href="#add-a-key-overwrite-multiple-keys-update">Add a key (overwrite) /multiple keys  <strong>.update()</strong></a></li>
<li><a href="#del">Del</a></li>
<li><a href="#list-comprehensions-to-dictionaries">List Comprehensions to Dictionaries</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#using-dictionaries">Using Dictionaries</a>
<ul>
<li><a href="#key-points-2">Key points:</a>
<ul>
<li><a href="#tryexcept-to-get-a-key">Try/Except to Get a Key</a></li>
<li><a href="#safely-get-a-key-for-safe-input-get">Safely Get a Key for safe input   <strong>.get()</strong></a></li>
<li><a href="#delete-a-key-pop">Delete a key <strong>.pop( )</strong></a></li>
<li><a href="#get-all-keys-keys">Get All Keys  <strong>.keys( )</strong></a></li>
<li><a href="#get-all-values">Get all values</a></li>
<li><a href="#get-all-items">Get All Items</a></li>
</ul>
</li>
<li><a href="#project-01-scrabble">Project 01 — Scrabble</a></li>
<li><a href="#project-02-unique-values">Project 02— unique Values</a></li>
</ul>
</li>
</ul>
</p>
<p>[toc]</p>
<h1 id="faqs">FAQs</h1>
<h2 id="1-一次获取字典多个值">1. 一次获取字典多个值</h2>
<p><strong>问题描述</strong></p>
<p>无法通过 <code>.get()</code> 方法传入多个键值获得字典多个值</p>
<pre><code class="language-python">&gt;&gt;&gt; list1 = ['one', 'two', 'three']
&gt;&gt;&gt; list2 = [1, 2, 3]
&gt;&gt;&gt; mydict = dict(zip(list1,list2))
&gt;&gt;&gt; mydict.get('one')
1
&gt;&gt;&gt; mydict.get('one','two')
1
&gt;&gt;&gt; mydict['one']
1
&gt;&gt;&gt; mydict['one','two']
Traceback (most recent call last):
  File &quot;&lt;pyshell#9&gt;&quot;, line 1, in &lt;module&gt;
    mydict['one','two']
KeyError: ('one', 'two')
</code></pre>
<p><strong>解决方法1</strong> ： from operator import itemgetter</p>
<pre><code class="language-python">from operator import itemgetter
&gt;&gt;&gt; itemgetter('one','two')(mydict) # 传入键值
(1, 2)
&gt;&gt;&gt; itemgetter(*['one','two'])(mydict)# 传入字典列表，加*
(1, 2)
&gt;&gt;&gt; itemgetter(['one','two'])(mydict) # 传入字典列表，不加*
Traceback (most recent call last):
  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;
    itemgetter(['one','two'])(mydict)
TypeError: unhashable type: 'list'
</code></pre>
<p><strong>解决方法2</strong>：from pydash import at (该方法需要安装 pydash 模块)</p>
<pre><code class="language-python">from pydash import at
dict = {'a': 1, 'b': 2, 'c': 3}
list = at(dict, 'a', 'b')
list == [1, 2]
</code></pre>
<h2 id="2-函数返回值为字典">2. 函数返回值为字典</h2>
<pre><code class="language-python">def func1():
    parameters = {'a':1,'b':2,'c':3}
    return parameters
    
func1().get('a')
输出：1
</code></pre>
<h1 id="introduction-to-dictionary">Introduction to Dictionary</h1>
<h2 id="definition">Definition:</h2>
<p>A dictionary is an unordered set of key: value pairs.</p>
<pre><code class="language-python">menu = {&quot;oatmeal&quot;: 3, &quot;avocado toast&quot;: 6, &quot;carrot juice&quot;: 5, &quot;blueberry muffin&quot;: 2}
</code></pre>
<ol>
<li>A dictionary begins and ends with curly braces (<code>{</code> and <code>}</code>).</li>
<li>Each item consists of a <em>key</em> (i.e., “oatmeal”) and a value (i.e., 3)</li>
<li>Each key: value pair (i.e., <code>&quot;oatmeal&quot;: 3</code> or <code>&quot;avocado toast&quot;: 6</code>) is separated by a comma (<code>,</code>)</li>
<li>It’s considered good practice to insert a space () after each comma, but your code will still run without the space.</li>
</ol>
<p><strong>Difference between dictionary and list</strong></p>
<p><code>List</code>:  a collection of oredered objetcs</p>
<p><code>Dictionary</code>: a collection of unordered objects</p>
<h2 id="benifits">Benifits:</h2>
<ul>
<li>Use a key to get a value from a dictionary</li>
<li>Check for existence of keys</li>
<li>Find the length of a dictionary</li>
<li>Iterate through keys and values in dictionaries</li>
<li>Describe related information of an object using a bunch of key-value pair In a complex scenario</li>
<li>put many dict in a list, iterating each of elemen for the same operation</li>
</ul>
<pre><code class="language-python">card_list = [{&quot;name&quot;: &quot;张三&quot;,
              &quot;qq&quot;: &quot;12345&quot;,
              &quot;phone&quot;: &quot;110&quot;},
             {&quot;name&quot;: &quot;李四&quot;,
              &quot;qq&quot;: &quot;54321&quot;,
              &quot;phone&quot;: &quot;10086&quot;}
             ]
</code></pre>
<h2 id="key-points">Key points:</h2>
<ul>
<li>
<p>list or dictionary can not be key</p>
<p>string，number,  tuple (immutable)</p>
</li>
<li>
<p>Hash the key to determine how to store the dictionary's data in memory</p>
<ul>
<li>key : immutable data type</li>
<li>value : any type of data</li>
</ul>
</li>
</ul>
<h3 id="inspect">Inspect</h3>
<pre><code class="language-python">dict.keys()
dict.values()
dict.items()
</code></pre>
<h3 id="add-a-key-overwrite-multiple-keys-update">Add a key (overwrite) /multiple keys  <strong>.update()</strong></h3>
<pre><code class="language-python"># add a key
Dict[key] = value
if key has existed, To modify previous data
Dict.setdefault(key,value)
if key has existed, Keep the original one

animals_in_zoo={}
animals_in_zoo[&quot;zebras&quot;] = 8
animals_in_zoo[&quot;monkeys&quot;] = 12
animals_in_zoo[&quot;dinosaurs&quot;] = 0
animals_in_zoo[&quot;dinosaurs&quot;] = 2
print(animals_in_zoo)

# multiple keys
user_ids.update({&quot;theLooper&quot;:138475, &quot;stringQueen&quot;: 85739})

# overwrite
oscar_winners = {&quot;Best Picture&quot;: &quot;La La Land&quot;, &quot;Best Actor&quot;: &quot;Casey Affleck&quot;, &quot;Best Actress&quot;: &quot;Emma Stone&quot;, &quot;Animated Feature&quot;: &quot;Zootopia&quot;}
oscar_winners[&quot;Supporting Actress&quot;] = &quot;Viola Davis&quot;
oscar_winners[&quot;Best Picture&quot;] = &quot;Moonlight&quot;
</code></pre>
<h3 id="del">Del</h3>
<pre><code class="language-python">del dict[key]
dict.pop(key)  
dict.popitem()    # randomly delete
dict.clear()
</code></pre>
<h3 id="list-comprehensions-to-dictionaries">List Comprehensions to Dictionaries</h3>
<pre><code class="language-python">names = ['Jenny', 'Alexus', 'Sam', 'Grace']
heights = [61, 70, 67, 64]
students = {key:value for key, value in zip(names, heights)}
#students is now {'Jenny': 61, 'Alexus': 70, 'Sam': 67, 'Grace': 64}

Takes a pair from the zipped list of pairs from names and heights
Names the elements in the pair key (the one originally from the names list) and value (the one originally from the heights list)
Creates a key : value item in the students dictionary
Repeats steps 1-3 for the entire list of pairs
</code></pre>
<pre><code class="language-python">songs = [&quot;Like a Rolling Stone&quot;, &quot;Satisfaction&quot;, &quot;Imagine&quot;, &quot;What's Going On&quot;, &quot;Respect&quot;, &quot;Good Vibrations&quot;]
playcounts = [78, 29, 44, 21, 89, 5]
plays = {song:playcount for song, playcount in zip(songs,playcounts)}
print(plays)
plays[&quot;Purple Haze&quot;] = 1
plays[&quot;Respect&quot;] = 94

library = {&quot;The Best Songs&quot;: plays, &quot;Sunday Feelings&quot;: {}}
print(library)
</code></pre>
<h1 id="using-dictionaries">Using Dictionaries</h1>
<h2 id="key-points-2">Key points:</h2>
<h3 id="tryexcept-to-get-a-key">Try/Except to Get a Key</h3>
<pre><code class="language-python">caffeine_level = {&quot;espresso&quot;: 64, &quot;chai&quot;: 40, &quot;decaf&quot;: 0, &quot;drip&quot;: 120}

caffeine_level[&quot;matcha&quot;] = 30
key_to_check = &quot;matcha&quot;
try:
  print(caffeine_level[ key_to_check])
except KeyError:
  print(&quot;Unknown Caffeine Level&quot;)
</code></pre>
<h3 id="safely-get-a-key-for-safe-input-get">Safely Get a Key for safe input   <strong>.get()</strong></h3>
<pre><code class="language-python"># specify a value if the key doesn't exist
&gt;&gt;&gt; building_heights.get('Shanghai Tower', 0)
632
&gt;&gt;&gt; building_heights.get('Mt Olympus', 0)
0
&gt;&gt;&gt; building_heights.get('Kilimanjaro', 'No Value')
'No Value'
</code></pre>
<h3 id="delete-a-key-pop">Delete a key <strong>.pop( )</strong></h3>
<pre><code class="language-python">raffle = {223842: &quot;Teddy Bear&quot;, 872921: &quot;Concert Tickets&quot;, 320291: &quot;Gift Basket&quot;, 412123: &quot;Necklace&quot;, 298787: &quot;Pasta Maker&quot;}
raffle.pop(320291, &quot;No Prize&quot;)
&quot;Gift Basket&quot;
# 存在则返回键值，不存在则返回逗号后值
</code></pre>
<h3 id="get-all-keys-keys">Get All Keys  <strong>.keys( )</strong></h3>
<pre><code class="language-python">user_ids = {&quot;teraCoder&quot;: 100019, &quot;pythonGuy&quot;: 182921, &quot;samTheJavaMaam&quot;: 123112, &quot;lyleLoop&quot;: 102931, &quot;keysmithKeith&quot;: 129384}
num_exercises = {&quot;functions&quot;: 10, &quot;syntax&quot;: 13, &quot;control flow&quot;: 15, &quot;loops&quot;: 22, &quot;lists&quot;: 19, &quot;classes&quot;: 18, &quot;dictionaries&quot;: 18}

users = user_ids.keys()
users1 = list(user_ids)
lessons = num_exercises.keys()

print(users)
print(users1)
print(lessons)

dict_keys(['teraCoder', 'pythonGuy', 'samTheJavaMaam', 'lyleLoop', 'keysmithKeith'])
A dict_keys object is a view object, which provides a look at the current state of the dicitonary, without the user being able to modify anything.
['teraCoder', 'pythonGuy', 'samTheJavaMaam', 'lyleLoop', 'keysmithKeith']

dict_keys(['functions', 'syntax', 'control flow', 'loops', 'lists', 'classes', 'dictionaries'])
</code></pre>
<h3 id="get-all-values">Get all values</h3>
<pre><code class="language-python">num_exercises = {&quot;functions&quot;: 10, &quot;syntax&quot;: 13, &quot;control flow&quot;: 15, &quot;loops&quot;: 22, &quot;lists&quot;: 19, &quot;classes&quot;: 18, &quot;dictionaries&quot;: 18}
total_exercises = 0
for num in num_exercises.values():
  total_exercises += num
print (total_exercises)
</code></pre>
<h3 id="get-all-items">Get All Items</h3>
<pre><code class="language-python">pct_women_in_occupation = {&quot;CEO&quot;: 28, &quot;Engineering Manager&quot;: 9, &quot;Pharmacist&quot;: 58, &quot;Physician&quot;: 40, &quot;Lawyer&quot;: 37, &quot;Aerospace Engineer&quot;: 9}
for occupation, value in pct_women_in_occupation.items():
  print(&quot;Women make up &quot; +str(value) +&quot; percent of &quot;+occupation+ &quot;s.&quot;)
</code></pre>
<h2 id="project-01-scrabble">Project 01 — Scrabble</h2>
<pre><code class="language-python">letters = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;]
points = [1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 4, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10]

letter_to_points = {letter: point for letter, point in zip(letters, points)}
letter_to_points[&quot; &quot;]=0

def score_word(word):
  point_total = 0
  for letter in word:
    point_total += letter_to_points.get(letter,0)
  return point_total

brownie_points = score_word(&quot;BROWNIE&quot;)
#print(brownie_points)
player_to_words = {&quot;wordNerd&quot;: &quot;EARTH EYES MACHINE&quot;, &quot;Lexi Con&quot;: &quot;ERASER BELLY HUSKY&quot; , &quot;Prof Reader&quot;: &quot;ZAP	COMA PERIOD&quot;}
player_to_points = {}

for item in player_to_words:
  player_points = 0
  for word in player_to_words[item]:
    player_points += score_word(word)
  player_to_points[item] = player_points
print(player_to_points)
</code></pre>
<h2 id="project-02-unique-values">Project 02— unique Values</h2>
<pre><code class="language-python">oscars = {&quot;Best Picture&quot;: &quot;Moonlight&quot;, &quot;Best Actor&quot;: &quot;Casey Affleck&quot;, &quot;Best Actress&quot;: &quot;Emma Stone&quot;, &quot;Animated Feature&quot;: &quot;Zootopia&quot;}

for element in oscars:
  print(element)

# Unique Values
def unique_values (my_dictionary):
  num_value = 0
  before_letter = []
  for value in my_dictionary.values():
    if not value in  before_letter:
      num_value += 1
    before_letter.append(value)
  return num_value
# Uncomment these function calls to test your  function:
# print(unique_values({0:3, 1:1, 4:1, 5:3}))
# should print 2
# print(unique_values({0:3, 1:3, 4:3, 5:3}))
# should print 1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 装饰器用法]]></title>
        <id>https://numantia.github.io/post/python-advanced-decorator/</id>
        <link href="https://numantia.github.io/post/python-advanced-decorator/">
        </link>
        <updated>2021-06-23T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8">为什么要用装饰器</a></li>
<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90">装饰器机制分析</a></li>
<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%85%A5%E9%97%A8">装饰器入门</a>
<ul>
<li><a href="#1-%E5%AF%B9%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%A3%85%E9%A5%B0">1. 对带参数的函数进行装饰</a></li>
<li><a href="#2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E4%B8%8D%E7%A1%AE%E5%AE%9A">2. 函数参数数量不确定</a></li>
<li><a href="#3-%E8%A3%85%E9%A5%B0%E5%99%A8%E5%B8%A6%E5%8F%82%E6%95%B0">3. 装饰器带参数</a></li>
<li><a href="#4-functoolswraps-%E8%BF%98%E5%8E%9F%E5%87%BD%E6%95%B0%E5%8E%9F%E4%BF%A1%E6%81%AF">4. functools.wraps - 还原函数原信息</a></li>
<li><a href="#5-%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%8F%82%E6%95%B0%E5%92%8C%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E8%87%AA%E9%80%82%E5%BA%94">5. 实现带参数和不带参数的装饰器自适应</a></li>
<li><a href="#6-%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8">6. 类装饰器</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">装饰器应用场景</a>
<ul>
<li><a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81">用户验证</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E5%90%88%E7%90%86%E6%80%A7%E6%A3%80%E6%9F%A5">输入合理性检查</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E5%8C%96">输出格式化</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7">异常捕获</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86">日志管理</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E8%A3%85%E9%A5%B0%E5%99%A8">缓存装饰器</a></li>
</ul>
</li>
</ul>
</p>
<p>[toc]</p>
<pre><code class="language-python">@dec
def func():
    pass
</code></pre>
<p>装饰器（Decorator）为装饰对象的器件，既可以装饰[函数](# 1. 对带参数的函数进行装饰)，又可以装饰[类](# 6. 类装饰器)。可以在不修改代码条件下，为装饰对象添加新的功能或者帮助输出。装饰器的典型应用场景有<a href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5">类型检查</a>、<a href="#%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81">用户验证</a>、<a href="#%E8%BE%93%E5%85%A5%E5%90%88%E7%90%86%E6%80%A7%E6%A3%80%E6%9F%A5">输入合理性检查</a>、<a href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E5%8C%96">输出格式化</a>、<a href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7">异常捕获</a>、<a href="#%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86">日志管理</a>。</p>
<h1 id="为什么要用装饰器">为什么要用装饰器</h1>
<p>在<a href="https://github.com/micheles/decorator/blob/master/docs/documentation.md">官方文档</a>中，Python 2.4 引入的<code>decorators</code> , 具有重要优势：</p>
<blockquote>
<ul>
<li>decorators help reducing boilerplate code;  减少样板代码</li>
<li>decorators help separation of concerns;  分离关注点</li>
<li>decorators enhance readability and maintenability; 增强可读性和可维护性</li>
<li>decorators are explicit. 显示的装饰器</li>
</ul>
</blockquote>
<ol>
<li>
<p><a href="mailto:michele.simionato@gmail.com"> michele.simionato</a> 开发的 <code>decorator</code> 模块，简化了<code>decorators</code>的使用，并附上了许多经典案例。</p>
</li>
<li>
<p><a href="https://www.cnblogs.com/arvin-feng/p/11108799.html">Python 装饰器用法实例总结</a>第二节有简单的例子，解释符合开放封闭原则，降低多函数重复代码量和频繁改动，将非核心的日志记录功能和函数分离开，有利于保证核心业务代码的简洁和易理解性。</p>
</li>
<li>
<p><a href="https://www.liujiangblog.com/course/python/39">Python 装饰器</a> 中经过用户验证场景不同解决方案的更迭来说明装饰器的优势。</p>
</li>
</ol>
<blockquote>
<p>使用装饰器@outer，也是仅需对基础平台的代码进行拓展，就可以实现在其他部门调用函数 API 之前都进行认证操作，在操作结束后保存日志，并且其他业务部门无需对他们自己的代码做任何修改，调用方式也不用变。</p>
</blockquote>
<h1 id="装饰器机制分析">装饰器机制分析</h1>
<p>本节摘自<a href="https://www.liujiangblog.com/course/python/39">Python 装饰器</a> ，在其基础上补充更为直观的图示和流程图说明，文字描述可以详细查看原文章。</p>
<pre><code class="language-python">def outer(func):
    def inner():
        print(&quot;认证成功！&quot;)
        result = func()
        print(&quot;日志添加成功&quot;)
        return result
    return inner

@outer
def f1():
    print(&quot;业务部门1数据接口......&quot;)

r = f1()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://numantia.github.io/post-images/decorator-mechanism.png" alt="decorator-mechanism" loading="lazy"></figure>
<p>​													                装饰器工作机制</p>
<figure data-type="image" tabindex="2"><img src="https://numantia.github.io/post-images/decorator-mechanism2.png" alt="decorator-mechanism2" loading="lazy"></figure>
<p>​															装饰器工作流程图</p>
<pre><code class="language-python"># 验证 inner 函数返回给 f1，即 f1 对象内存指向 inner内存

def outer(func):
    print(&quot;传入实参内存地址：%d&quot; %id(func))
    def inner():
        print(&quot;认证成功！&quot;)
        result = func()
        print(&quot;日志添加成功&quot;)
        return result
    print(&quot;Outer 内部函数 inner 内存地址：%d&quot; %id(inner))
    return inner

@outer
def f1():
    print(&quot;业务部门1数据接口......&quot;)

print(&quot;装饰后 f1 函数内存地址：%d&quot; %id(f1))
r = f1()

&gt;&gt;&gt; 输出结果
传入实参内存地址：32354376
Outer 内部函数 inner 内存地址：32372632
装饰后 f1 函数内存地址：32372632
认证成功！
业务部门1数据接口......
日志添加成功
</code></pre>
<h1 id="装饰器入门">装饰器入门</h1>
<p>本节摘自<a href="https://www.cnblogs.com/arvin-feng/p/11108799.html">Python装饰器用法实例总结</a></p>
<h2 id="1-对带参数的函数进行装饰">1. 对带参数的函数进行装饰</h2>
<p>内层函数进行改动传入我们的两个参数a和b，等价于use_logging(bar)(1,2)</p>
<pre><code class="language-python">def use_logging(func):
  def _deco(a,b):
    print(&quot;%s is running&quot; % func.__name__)
    func(a,b)
  return _deco
@use_logging
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,2)
</code></pre>
<h2 id="2-函数参数数量不确定">2. 函数参数数量不确定</h2>
<p>使用python的变长参数 *args和**kwargs 解决不定参数问题</p>
<pre><code class="language-python">def use_logging(func):
  def _deco(*args,**kwargs):
    print(&quot;%s is running&quot; % func.__name__)
    func(*args,**kwargs)
  return _deco
@use_logging
def bar(a,b):
  print('i am bar:%s'%(a+b))
@use_logging
def foo(a,b,c):
  print('i am bar:%s'%(a+b+c))
bar(1,2)
foo(1,2,3)
</code></pre>
<h2 id="3-装饰器带参数">3. 装饰器带参数</h2>
<pre><code class="language-python">#! /usr/bin/env python
# -*- coding:utf-8 -*-
# __author__ = &quot;TKQ&quot;
def use_logging(level):
  def _deco(func):
    def __deco(*args, **kwargs):
      if level == &quot;warn&quot;:
        print &quot;%s is running&quot; % func.__name__
      return func(*args, **kwargs)
    return __deco
  return _deco
@use_logging(level=&quot;warn&quot;)
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,3)
# 等价于use_logging(level=&quot;warn&quot;)(bar)(1,3)
</code></pre>
<h2 id="4-functoolswraps-还原函数原信息">4. functools.wraps - 还原函数原信息</h2>
<p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、<strong>name</strong>、参数列表</p>
<pre><code class="language-python">def use_logging(func):
  def _deco(*args,**kwargs):
    print(&quot;%s is running&quot; % func.__name__)
    func(*args,**kwargs)
  return _deco
@use_logging
def bar():
  print('i am bar')
  print(bar.__name__)
bar()
#bar is running
#i am bar
#_deco
#函数名变为_deco而不是bar，这个情况在使用反射的特性的时候就会造成问题。因此引入了functools.wraps解决这个问题。
</code></pre>
<pre><code class="language-python"># 使用functools.wraps:
import functools
def use_logging(func):
  @functools.wraps(func)
  def _deco(*args,**kwargs):
    print(&quot;%s is running&quot; % func.__name__)
    func(*args,**kwargs)
  return _deco
@use_logging
def bar():
  print('i am bar')
  print(bar.__name__)
bar()
#result:
#bar is running
#i am bar
#bar ,这个结果是我们想要的。OK啦！
</code></pre>
<h2 id="5-实现带参数和不带参数的装饰器自适应">5. 实现带参数和不带参数的装饰器自适应</h2>
<pre><code class="language-python">import functools
def use_logging(arg):
  if callable(arg):#判断参入的参数是否是函数，不带参数的装饰器调用这个分支
    @functools.wraps(arg)
    def _deco(*args,**kwargs):
      print(&quot;%s is running&quot; % arg.__name__)
      arg(*args,**kwargs)
    return _deco
  else:#带参数的装饰器调用这个分支
    def _deco(func):
      @functools.wraps(func)
      def __deco(*args, **kwargs):
        if arg == &quot;warn&quot;:
          print &quot;warn%s is running&quot; % func.__name__
        return func(*args, **kwargs)
      return __deco
    return _deco
@use_logging(&quot;warn&quot;)
# @use_logging
def bar():
  print('i am bar')
  print(bar.__name__)
bar()
</code></pre>
<h2 id="6-类装饰器">6. 类装饰器</h2>
<p>使用类装饰器可以实现带参数装饰器的效果，但实现的更加优雅简洁,而且可以通过继承来灵活的扩展.</p>
<pre><code class="language-python">class loging(object):
  def __init__(self,level=&quot;warn&quot;):
    self.level = level
  def __call__(self,func):
    @functools.wraps(func)
    def _deco(*args, **kwargs):
      if self.level == &quot;warn&quot;:
        self.notify(func)
      return func(*args, **kwargs)
    return _deco
  def notify(self,func):
    # logit只打日志，不做别的
    print &quot;%s is running&quot; % func.__name__
@loging(level=&quot;warn&quot;)  #执行__call__方法
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,3)
</code></pre>
<p><strong>继承扩展类装饰器</strong></p>
<pre><code class="language-python">class email_loging(Loging):
  '''
  	一个loging的实现版本，可以在函数调用时发送email给管理员
  	__init__ ：不再接收被装饰函数，而是接收传入参数。
	__call__ ：接收被装饰函数，实现装饰逻辑。
  '''
  def __init__(self, email='admin@myproject.com', *args, **kwargs):
    self.email = email
    super(email_loging, self).__init__(*args, **kwargs)
  def notify(self,func):
    # 发送一封email到self.email
    print &quot;%s is running&quot; % func.__name__
    print &quot;sending email to %s&quot; %self.email
@email_loging(level=&quot;warn&quot;)
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,3)
arvin_feng
</code></pre>
<h1 id="装饰器应用场景">装饰器应用场景</h1>
<p>该节摘抄记录自文章<a href="http://c.biancheng.net/view/5410.html">Python装饰器的应用场景</a>，文章<a href="https://www.cnblogs.com/superhin/p/11454823.html">Python装饰器的应用场景</a></p>
<h2 id="类型检查">类型检查</h2>
<pre><code class="language-python">from functools import wraps
def require_ints(func):
  @wraps(func) # 将func的信息复制给inner
  def inner(*args, **kwargs):
    for arg list(args) + list(kwargs.values()):
      if not isinstance(arg, int:
        raise TypeError(&quot;{} 只接受int类型参数&quot;.format(func.__name__)
    return func(*args, **kwargs)
  return inner
</code></pre>
<h2 id="用户验证">用户验证</h2>
<p>定义了装饰器 authenticate，函数 post_comment() 则表示发表用户对某篇文章的评论，每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。</p>
<pre><code class="language-python">import functools

def authenticate(func):
    @functools.wraps(func)
    # @functools.wraps(func) 也是一个装饰器，
    # 不使用它，则 post_comment.__name__ 的值为 wrapper。
    # 使用它之后，则 post_comment.__name__ 的值依然为 post_comment。
    def wrapper(*args, **kwargs):
        request = args[0]
        # 如果用户处于登录状态
        if check_user_logged_in(request):
            # 执行函数 post_comment()
            return func(*args, **kwargs)  
        else:
            raise Exception('Authentication failed')
    return wrapper
   
@authenticate
def post_comment(request, ...)
    ...
</code></pre>
<h2 id="输入合理性检查">输入合理性检查</h2>
<p>在大型公司的机器学习框架中，调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检查。这样就可以</p>
<ol>
<li>大大避免输入不正确对机器造成的巨大开销。其实在工作中，很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现。</li>
<li>如果没有输入的合理性检查，很容易出现“模型训练了好几个小时后，系统却报错说输入的一个参数不对，成果付之一炬”的现象。这样的“惨案”，大大减缓了开发效率，也对机器资源造成了巨大浪费。</li>
</ol>
<pre><code class="language-python">import functools

def validation_check(input):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        ... # 检查输入是否合法
   
@validation_check
def neural_network_training(param1, param2, ...):
    ...
</code></pre>
<h2 id="输出格式化">输出格式化</h2>
<pre><code class="language-python">import json
from functools import wraps

def json_output(func):  # 将原本func返回的字典格式转为返回json字符串格式
    @wrap(func)
    def inner(*args, **kwargs):
        return json.dumps(func(*args, **kwargs))
    return inner
</code></pre>
<h2 id="异常捕获">异常捕获</h2>
<pre><code class="language-python">import json
from functools import wraps

class Error1(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return self.msg
        

def json_output(func):
    @wrap(func)
    def inner(*args, **kwargs):
        try:
            result = func(*args, **kwargs)
        except Error1 as ex:
            result = {&quot;status&quot;: &quot;error&quot;, &quot;msg&quot;: str(ex)}
        return json.dumps(result)
    return inner

# 使用方法
@json_ouput
def error():
    raise Error1(&quot;该条异常会被捕获并按JSON格式输出&quot;)
</code></pre>
<h2 id="日志管理">日志管理</h2>
<p>测试函数耗时，装饰器方式秉持开放封闭原则，无需调增函数体内部，而是通过外部封装方式，减少耦合。</p>
<pre><code class="language-python">import time
import logging
from functools import wraps

def logged(func):
    @wraps(func)
    def inner(*args, **kwargs):  # *args可以装饰函数也可以装饰类
        start = time.time()
        result = func(*args, **kwargs)
        exec_time = time.time() - start
        logger = logging.getLoger(&quot;func.logged&quot;)
        logger.warning(&quot;{} 调用时间:{:.2} 执行时间:{:.2}s 结果:{}&quot;.format(func.__name__, start, exec_time, result)

def calculate_similarity(items):
    ...
</code></pre>
<h2 id="缓存装饰器">缓存装饰器</h2>
<p>关于缓存装饰器的用法，其实十分常见，这里以 <a href="http://c.biancheng.net/python/">Python</a> 内置的 LRU cache 为例来说明。LRU cache，在 Python 中的表示形式是 @lru_cache。@lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除最近最久未使用的数据。</p>
<p>正确使用缓存装饰器，往往能极大地提高程序运行效率。举个例子，大型公司服务器端的代码中往往存在很多关于设备的检查，比如使用的设备是安卓还是 iPhone，版本号是多少。这其中的一个原因，就是一些新的功能，往往只在某些特定的手机系统或版本上才有。这样一来，我们通常使用缓存装饰器来包裹这些检查函数，避免其被反复调用，进而提高程序运行效率，比如写成下面这样：</p>
<pre><code class="language-python">@lru_cache
def check(param1, param2, ...) # 检查用户设备类型，版本号等等
    ...
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 数据类型之 list（讲解+案例+FAQs）]]></title>
        <id>https://numantia.github.io/post/python-dtype-list/</id>
        <link href="https://numantia.github.io/post/python-dtype-list/">
        </link>
        <updated>2021-06-18T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<p><ul class="markdownIt-TOC">
<li><a href="#faqs">FAQs</a>
<ul>
<li><a href="#1-list-comprehension-%E5%8F%8C%E5%BE%AA%E7%8E%AF">1. List Comprehension - 双循环</a></li>
<li><a href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">2. 初始化一维数组+二维数组</a></li>
<li><a href="#3-typeerror-list-indices-must-be-integers-or-slices-not-tuple">3. TypeError: list indices must be integers or slices, not tuple</a></li>
<li><a href="#4-indexerror-list-assignment-index-out-of-range">4. IndexError: list assignment index out of range</a></li>
<li><a href="#5-typeerror-list-object-is-not-callable">5. TypeError: 'list' object is not callable</a></li>
<li><a href="#6-python-%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E9%87%8C%E5%85%83%E7%B4%A0%E5%AF%B9%E5%BA%94%E7%9B%B8%E4%B9%98">6. Python 实现两个列表里元素对应相乘</a></li>
<li><a href="#7-list-%E5%88%A4%E6%96%AD%E7%A9%BA%E4%B8%8E%E9%9D%9E%E7%A9%BA">7. List 判断空与非空</a></li>
<li><a href="#8-listappend-%E8%BE%93%E5%87%BA%E4%B8%BAnone">8. List.append() 输出为None</a></li>
<li><a href="#9-list-%E5%90%88%E5%B9%B6%E5%88%A4%E6%96%AD%E5%88%97%E8%A1%A8%E4%B8%BA%E7%BB%B4%E6%95%B0">9. List 合并，判断列表为维数</a></li>
<li><a href="#10-float-%E5%9E%8B%E5%88%97%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%B8%BA-int-%E5%9E%8B%E5%88%97%E8%A1%A8">10. Float 型列表转化为 Int 型列表</a></li>
</ul>
</li>
<li><a href="#creating-a-list-in-python">Creating a List in Python</a>
<ul>
<li><a href="#definition">Definition:</a></li>
<li><a href="#benifits">Benifits:</a></li>
<li><a href="#key-points">Key points:</a>
<ul>
<li><a href="#ziplist1list2">zip(list1,list2)</a></li>
<li><a href="#list-modifying-operation">List modifying operation</a></li>
<li><a href="#range">Range()</a></li>
<li><a href="#project-01gradebook">Project 01—Gradebook</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#modifying-python-lists">Modifying python lists</a>
<ul>
<li><a href="#definition-2">Definition:</a></li>
<li><a href="#benifits-2">Benifits:</a></li>
<li><a href="#key-points-2">Key points:</a>
<ul>
<li><a href="#get-the-length-of-a-list-len">Get the length of a list <strong>len()</strong></a></li>
<li><a href="#select-subsets-of-a-list-called-slicing-1">Select subsets of a list (called <em><strong>slicing</strong></em>)  [ ] [-1] [:]</a></li>
<li><a href="#count-the-number-of-times-that-an-element-appears-in-a-list-letterscounti">Count the number of times that an element appears in a list <strong>letters.count('i')</strong></a></li>
<li><a href="#sort-a-list-of-items-sort-sorted">Sort a list of items ****.sort()   sorted(<strong>)</strong></a></li>
<li><a href="#project-01-lens-slice">Project 01 — Len's Slice</a></li>
<li><a href="#project-02-list-aggregate">Project 02 —List Aggregate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#summary">Summary</a>
<ul>
<li><a href="#add"><strong>ADD</strong></a></li>
<li><a href="#modify"><strong>MODIFY</strong></a></li>
<li><a href="#del"><strong>DEL</strong></a></li>
<li><a href="#aggeregate-function"><strong>Aggeregate function</strong></a></li>
<li><a href="#sort"><strong>Sort</strong></a></li>
</ul>
</li>
</ul>
</p>
<h1 id="faqs">FAQs</h1>
<h2 id="1-list-comprehension-双循环">1. List Comprehension - 双循环</h2>
<pre><code class="language-python">ntest=['a','b']
ltest=[[1,2],[4,5,6]]
data=[(k,v) for k,l in zip(ntest,ltest) for v in l] 
</code></pre>
<p>https://blog.csdn.net/leavemetomorrow/article/details/90641362</p>
<h2 id="2-初始化一维数组二维数组">2. 初始化一维数组+二维数组</h2>
<pre><code class="language-python"># 一维数组
a = [None] * n # 方法1
a = [None for i in range(n)] # 方法2

&gt;&gt;&gt; [None, None, None, None, None]

# 二维数组
a = [list()] * 5 # 浅拷贝方法，所有List会同步变化
a[0].append(1)  # 方法1
&gt;&gt;&gt; [[1], [1], [1], [1], [1]]

a = [list() for i in range(5)] # 所有List独立
a[0].append(1)  # 方法2
&gt;&gt;&gt; [[1], [], [], [], []]
</code></pre>
<h2 id="3-typeerror-list-indices-must-be-integers-or-slices-not-tuple">3. TypeError: list indices must be integers or slices, not tuple</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; a=[[1,2,3],[4,5,6]]
&gt;&gt;&gt; a[0]    #取一行
[1, 2, 3]
&gt;&gt;&gt; a[:,0]  #尝试用数组的方法读取一列失败
TypeError: list indices must be integers or slices, not tuple
</code></pre>
<p><strong>产生原因</strong></p>
<p>列表存储不同类型数据，列表元素大小相同或者不同，不支持读取一列</p>
<p><strong>解决方法1</strong>：列表解析的方法</p>
<pre><code class="language-python">&gt;&gt;&gt; b=[x[0] for x in a]
&gt;&gt;&gt; print(b)
</code></pre>
<p><strong>解决方法2</strong>:  转化为数组直接读取</p>
<pre><code class="language-python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a=np.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; a[:,0]
array([1, 4])
</code></pre>
<h2 id="4-indexerror-list-assignment-index-out-of-range">4. IndexError: list assignment index out of range</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-python">m1=[]
for i in range(10):
	m1[i]=1
</code></pre>
<p><strong>产生原因</strong></p>
<p>空数组无法直接确定位置，因为内存中尚未分配</p>
<p>**解决方法1：**使用append方法</p>
<pre><code class="language-python">m1.append(1）
</code></pre>
<p>**解决方法2：**先生成一个定长的list</p>
<pre><code class="language-python">m1=[0]*len(data)
m1[1]=1
</code></pre>
<h2 id="5-typeerror-list-object-is-not-callable">5. TypeError: 'list' object is not callable</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-powershell">&gt;&gt;&gt; str = &quot;ABCDEF&quot;
&gt;&gt;&gt; list = [1, 2 ,3 ,4 ,5,6 ]
&gt;&gt;&gt; list(str)

TypeError: 'list' object is not callable
</code></pre>
<p><strong>产生原因</strong></p>
<p>callable() 是python 的内置函数，用来检查对象是否可被调用</p>
<p>变量list和函数list重名，所以函数在使用list函数时，发现list是一个定义好的列表，而列表是不能把被调用的，因此抛出一个类型错误</p>
<h2 id="6-python-实现两个列表里元素对应相乘">6. Python 实现两个列表里元素对应相乘</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-powershell">&gt;&gt;&gt; list1 = [1,2,3]
&gt;&gt;&gt; list2 = [4,5,6]
&gt;&gt;&gt; list1*list2

TypeError: can't multiply sequence by non-int of type 'list'
</code></pre>
<p><strong>解决方法1 ： Map函数</strong></p>
<pre><code class="language-python">List1 = [1,2,3,4]
List2 = [5,6,7,8]
List3 = map(lambda a,b:a*b,zip(List1,List2))
print List3
</code></pre>
<p><strong>解决方法2: np.multiply</strong></p>
<pre><code class="language-python">List1 = [1,2,3]
List2 = [5,6,7]
List3 = np.multiply(np.array(List1),np.array(List2))
print List3.tolist()
</code></pre>
<h2 id="7-list-判断空与非空">7. List 判断空与非空</h2>
<pre><code class="language-python"># 一、二维通用
list = []
if list:
    print('非空')
if not list:
    print('空')
</code></pre>
<h2 id="8-listappend-输出为none">8. List.append() 输出为None</h2>
<p><strong>问题描述</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; a = []
&gt;&gt;&gt; a =  a.append(1)
&gt;&gt;&gt; print(a)
None
</code></pre>
<p><strong>产生原因</strong></p>
<p>append 方法不是返回一个列表，而只是修改原来的列表，所以如果用 <strong>等式</strong> 输出的话，返回是<code>None</code></p>
<p><strong>解决方法</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; a = []
&gt;&gt;&gt; a.append(1)
&gt;&gt;&gt; print(a)
1
</code></pre>
<h2 id="9-list-合并判断列表为维数">9. List 合并，判断列表为维数</h2>
<pre><code class="language-python"># 两个列表交叉合并
a=[1,2,3,4,5]
b=[2,3,4,5,6]
c=[]
for x,y in zip(a,b):
    c.append([x,y])
print(c)

result ： [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]

# 二维列表的合并
a=[1,2,3,4,5]
b=[2,3,4,5,6]
c = [a,b]
d = []
for x,y in zip(*c):
    d.append([x,y])
print(d)

result ： [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]

# 
import numpy as np
a=[0.1,0.2, 0.1, 0.1, 0.1, 0.1]
b=[[0.1, 0.1], [0.2, 0.1], [0.1, 0.1]]
c=[[[0.1,0.5], [0.1,0.8]]]

L1=np.array(a)
print(L1.shape)
print(len(L1.shape))
L=np.array(b)
print(L.shape)
print(len(L.shape))
L2=np.array(c)
print(L2.shape)
print(len(L2.shape))

result :
(6,)
1 # 1维
(3, 2)
2 # 2维
(1, 2, 2)
3 # 3维
</code></pre>
<h2 id="10-float-型列表转化为-int-型列表">10. Float 型列表转化为 Int 型列表</h2>
<p><strong>方法1:</strong> 使用map方法</p>
<pre><code class="language-python">&gt;&gt;&gt; list = [1.3, 2.3, 4, 5]　　　#带有float型的列表　
&gt;&gt;&gt; int_list = map(int,list)　　#使用map转换
&gt;&gt;&gt; print int_list　　　　　　　　
[1, 2, 4, 5]
</code></pre>
<p>**方法2：**使用for循环</p>
<pre><code class="language-python">list1 =  [1.3,2.3,4,5]
lista = []
for i in list1:
     i =int(i)
     lista.append(i)
print lista

[1, 2, 4, 5]
</code></pre>
<blockquote>
<p>参考<a href="https://www.cnblogs.com/xuchunlin/p/6305709.html">文章</a></p>
</blockquote>
<h1 id="creating-a-list-in-python">Creating a List in Python</h1>
<h2 id="definition">Definition:</h2>
<p><em>A list is an ordered set of objects in Python, combine multiple data types in one list.</em></p>
<h2 id="benifits">Benifits:</h2>
<h2 id="key-points">Key points:</h2>
<ul>
<li>heights = [61,<mark>space</mark> 70, 67, 64]  # To insert space between two element is recommended</li>
</ul>
<h3 id="ziplist1list2">zip(list1,list2)</h3>
<p>takes two (or more) lists as inputs and returns an object that contains a list of pairs.</p>
<pre><code class="language-python">names_and_heights = zip(names, heights)
print(names_and_heights)
because it will return the location of this object in memory. Output would look something like this:

&lt;zip object at 0x7f1631e86b48&gt;

To see the nested lists, you can convert the zip object to a list first:

print(list(names_and_heights))
returns:

[('Jenny', 61), ('Alexus', 70), ('Sam', 67), ('Grace', 65)]
</code></pre>
<h3 id="list-modifying-operation">List modifying operation</h3>
<pre><code class="language-python">#  add one item to a list
***.append()
def append_sum(lst):
  lst.append(lst[-1] + lst[-2])
  lst.append(lst[-1] + lst[-2])
  lst.append(lst[-1] + lst[-2])
  return lst
# Add multiple items to a list
+
gradebook + [(&quot;visual arts&quot;, 93)]
</code></pre>
<h3 id="range">Range()</h3>
<pre><code class="language-python">my_range = range(10)
&gt;&gt;&gt; print(my_range)
range(0, 10)

&gt;&gt;&gt; print(list(my_range))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

my_range3 = range(1, 100, 10)
before 100 在100之间不包括100
</code></pre>
<h3 id="project-01gradebook">Project 01—Gradebook</h3>
<pre><code class="language-python">last_semester_gradebook = [(&quot;politics&quot;, 80), (&quot;latin&quot;, 96), (&quot;dance&quot;, 97), (&quot;architecture&quot;, 65)]
subjects = [&quot;physics&quot;, &quot;calculus&quot;, &quot;poetry&quot;, &quot;history&quot;]
grades = [98, 97, 85, 88]
subjects.append(&quot;computer science&quot;)
grades.append(100)
gradebook=list(zip(subjects, grades))
gradebook + [(&quot;visual arts&quot;, 93)]
full_gradebook = gradebook + last_semester_gradebook
print (full_gradebook)
</code></pre>
<h1 id="modifying-python-lists">Modifying python lists</h1>
<h2 id="definition-2">Definition:</h2>
<p><em>How to work with existing lists of data</em></p>
<h2 id="benifits-2">Benifits:</h2>
<h2 id="key-points-2">Key points:</h2>
<h3 id="get-the-length-of-a-list-len">Get the length of a list <strong>len()</strong></h3>
<h3 id="select-subsets-of-a-list-called-slicing-1">Select subsets of a list (called <em><strong>slicing</strong></em>)  [ ] [-1] [:]</h3>
<pre><code class="language-python">shopping_list = ['eggs', 'butter', 'milk', 'cucumbers', 'juice', 'cereal']
print(shopping_list[len(shopping_list)-1])
# the last term of list
print(shopping_list[-1])
# 6 not included in the list 
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
sublist = letters[1:6]
print(sublist)

['b', 'c', 'd', 'e', 'f']

suitcase = ['shirt', 'shirt', 'pants', 'pants', 'pajamas', 'books']
start = suitcase[:3]
end = suitcase[-2:]
</code></pre>
<h3 id="count-the-number-of-times-that-an-element-appears-in-a-list-letterscounti">Count the number of times that an element appears in a list <strong>letters.count('i')</strong></h3>
<h3 id="sort-a-list-of-items-sort-sorted">Sort a list of items ****.sort()   sorted(<strong>)</strong></h3>
<pre><code class="language-python"># sort and sorted have different usuage

# Sort return &quot;none&quot;,after sort(),list will change itself
sorted_names = names.sort()
print(sorted_names)

lst.sort()
return lst

# sorted return sorted_list and have no change to original list
sorted_names = sorted(names)
</code></pre>
<h3 id="project-01-lens-slice">Project 01 — Len's Slice</h3>
<pre><code class="language-python">toppings =['pepperoni', 'pineapple', 'cheese', 'sausage', 'olives','anchovies', 'mushrooms', ]
prices= [2,6,1,3,2,7,2]
num_pizzas = len(toppings)
print (&quot;We sell &quot;+ str(num_pizzas) + &quot; different kinds of pizza!&quot;)

pizzas = list(zip(prices, toppings))

pizzas.sort()
print (pizzas)
cheapest_pizza = pizzas[0]
priciest_pizza = pizzas[-1]
print (&quot;I will have your MOST EXPENSIVE pizza!&quot;)
three_cheapest = pizzas[:3]
print(three_cheapest)

num_two_dollar_slices=prices.count(2)
print (num_two_dollar_slices)
</code></pre>
<h3 id="project-02-list-aggregate">Project 02 —List Aggregate</h3>
<pre><code class="language-python"># Double index
def double_index(lst,index):
  if index &lt;= len(lst)-1:
    lst[index]=lst[index]*2
    return lst
  else:
    return lst
  
print(double_index([3, 8, -10, 12], 2))
# Remove middle
def remove_middle(lst, start, end): 
  lst=lst[:start]+lst[end+1:]
  return lst

print(remove_middle([4, 8, 15, 16, 23, 42], 1, 3))

#More than N
def more_than_n (lst, item, n):
  if lst.count(item)&gt;n:
    return True
  else:
    return False

print(more_than_n([2, 4, 6, 2, 3, 2, 1, 2], 2, 3))

# More Frequent Item
def more_frequent_item (lst,item1,item2):
  if lst.count(item1) &gt;= lst.count(item2):
    return item1
  else:
    return item2
print(more_frequent_item([2, 3, 3, 2, 3, 2, 3, 2, 3], 2, 3))

# Middle Item
def middle_element(lst):
  if len(lst) % 2 == 0:
    sum = lst[int(len(lst)/2)] + lst[int(len(lst)/2) - 1]
    return sum / 2
  else:
    return lst[int(len(lst)/2)]

print(middle_element([5, 2, -10, -4, 4, 5]))
</code></pre>
<h1 id="summary">Summary</h1>
<h2 id="add"><strong>ADD</strong></h2>
<p>list.append(data)</p>
<p>list1.extend(list2)</p>
<p>liat1.insert(index,data)</p>
<h2 id="modify"><strong>MODIFY</strong></h2>
<p>list[index] = data</p>
<h2 id="del"><strong>DEL</strong></h2>
<p>del list[index]     # unrecommended</p>
<p>list.remove[data]  Delete specified element of first appearance in the list</p>
<p>list.pop()    delete the final one element</p>
<p>list.pop(index)  delete element at specific location</p>
<p>list.clear  delete the whole of list</p>
<h2 id="aggeregate-function"><strong>Aggeregate function</strong></h2>
<p>list.count(data)</p>
<p>len(list)</p>
<h2 id="sort"><strong>Sort</strong></h2>
<p>list.sort(reverse = true)    descending sort</p>
<p>list.reverse()    reverse the order</p>
<p>sorted()</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python print() 常见用法]]></title>
        <id>https://numantia.github.io/post/python-print/</id>
        <link href="https://numantia.github.io/post/python-print/">
        </link>
        <updated>2021-06-16T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
</code></pre>
<ul>
<li>objects -- 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。</li>
<li>sep -- 用来间隔多个对象，默认值是一个空格。</li>
<li>end -- 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。</li>
<li>file -- 要写入的文件对象。</li>
<li>flush -- 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新</li>
</ul>
<p><strong>例子1：输出字符串</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; print(&quot;aaa&quot;&quot;bbb&quot;)
aaabbb
&gt;&gt;&gt; print(&quot;aaa&quot;,&quot;bbb&quot;)
aaa bbb
&gt;&gt;&gt; 
 
&gt;&gt;&gt; print(&quot;www&quot;,&quot;runoob&quot;,&quot;com&quot;,sep=&quot;.&quot;)  # 设置间隔符
www.runoob.com
</code></pre>
<p><strong>例子2：实现 Loading 效果</strong></p>
<pre><code class="language-python">import time

print(&quot;Loading&quot;,end = &quot;&quot;) # 结尾不换行
for i in range(20):
    print(&quot;.&quot;,end = '',flush = True) #结尾不换行，缓存输出
    time.sleep(0.5)

#运行结果
Loading......
</code></pre>
<p><strong>例子3：Python format 格式化函数<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></strong></p>
<pre><code class="language-python">&gt;&gt;&gt;&quot;{} {}&quot;.format(&quot;hello&quot;, &quot;world&quot;)    # 不设置指定位置，按默认顺序
'hello world'
 
&gt;&gt;&gt; &quot;{0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;)  # 设置指定位置
'hello world'
 
&gt;&gt;&gt; &quot;{1} {0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;)  # 设置指定位置
'world hello world'
</code></pre>
<pre><code class="language-python"># 设置参数
print(&quot;网站名：{name}, 地址 {url}&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;))
 
# 通过字典设置参数
site = {&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;}
print(&quot;网站名：{name}, 地址 {url}&quot;.format(site))
 
# 通过列表索引设置参数
my_list = ['菜鸟教程', 'www.runoob.com']
print(&quot;网站名：{0[0]}, 地址 {0[1]}&quot;.format(my_list))  # &quot;0&quot; 是必须的
</code></pre>
<p><strong>例子4：.format() 格式化输出</strong></p>
<pre><code class="language-python">&gt;&gt;&gt; print(&quot;{:.2f}&quot;.format(3.1415926))
3.14
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">数字</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">输出</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">3.1415926</td>
<td style="text-align:left">{:.2f}</td>
<td style="text-align:left">3.14</td>
<td style="text-align:left">保留小数点后两位</td>
</tr>
<tr>
<td style="text-align:left">3.1415926</td>
<td style="text-align:left">{:+.2f}</td>
<td style="text-align:left">+3.14</td>
<td style="text-align:left">带符号保留小数点后两位</td>
</tr>
<tr>
<td style="text-align:left">-1</td>
<td style="text-align:left">{:+.2f}</td>
<td style="text-align:left">-1.00</td>
<td style="text-align:left">带符号保留小数点后两位</td>
</tr>
<tr>
<td style="text-align:left">2.71828</td>
<td style="text-align:left">{:.0f}</td>
<td style="text-align:left">3</td>
<td style="text-align:left">不带小数</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">{:0&gt;2d}</td>
<td style="text-align:left">05</td>
<td style="text-align:left">数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">{:x&lt;4d}</td>
<td style="text-align:left">5xxx</td>
<td style="text-align:left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">{:x&lt;4d}</td>
<td style="text-align:left">10xx</td>
<td style="text-align:left">数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td style="text-align:left">1000000</td>
<td style="text-align:left">{:,}</td>
<td style="text-align:left">1,000,000</td>
<td style="text-align:left">以逗号分隔的数字格式</td>
</tr>
<tr>
<td style="text-align:left">0.25</td>
<td style="text-align:left">{:.2%}</td>
<td style="text-align:left">25.00%</td>
<td style="text-align:left">百分比格式</td>
</tr>
<tr>
<td style="text-align:left">1000000000</td>
<td style="text-align:left">{:.2e}</td>
<td style="text-align:left">1.00e+09</td>
<td style="text-align:left">指数记法</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">{:&gt;10d}</td>
<td style="text-align:left">13</td>
<td style="text-align:left">右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">{:&lt;10d}</td>
<td style="text-align:left">13</td>
<td style="text-align:left">左对齐 (宽度为10)</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">{:^10d}</td>
<td style="text-align:left">13</td>
<td style="text-align:left">中间对齐 (宽度为10)</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><code>'{:b}'.format(11) '{:d}'.format(11) '{:o}'.format(11) '{:x}'.format(11) '{:#x}'.format(11) '{:#X}'.format(11)</code></td>
<td style="text-align:left"><code>1011 11 13 b 0xb 0XB</code></td>
<td style="text-align:left">进制</td>
</tr>
</tbody>
</table>
<p><strong>^</strong>, <strong>&lt;</strong>, <strong>&gt;</strong> 分别是居中、左对齐、右对齐，后面带宽度， <strong>:</strong> 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。</p>
<p><strong>+</strong> 表示在正数前显示 <strong>+</strong>，负数前显示 <strong>-</strong>； （空格）表示在正数前加空格</p>
<p>b、d、o、x 分别是二进制、十进制、八进制、十六进制。</p>
<p><strong>例子5： % 符号格式化输出<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></strong></p>
<pre><code class="language-python">&gt;&gt;&gt;pi = 3.141592653  
&gt;&gt;&gt; print('%10.3f' % pi) #字段宽10，精度3  
     3.142  
&gt;&gt;&gt; print(&quot;pi = %.*f&quot; % (3,pi)) #用*从后面的元组中读取字段宽度或精度  
pi = 3.142  
&gt;&gt;&gt; print('%010.3f' % pi) #用0填充空白  
000003.142  
&gt;&gt;&gt; print('%-10.3f' % pi) #左对齐  
3.142       
&gt;&gt;&gt; print('%+f' % pi) #显示正负号  
+3.141593
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">符  号</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%c</td>
<td style="text-align:left">格式化字符及其ASCII码</td>
</tr>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:left">格式化字符串</td>
</tr>
<tr>
<td style="text-align:left">%d</td>
<td style="text-align:left">格式化整数</td>
</tr>
<tr>
<td style="text-align:left">%u</td>
<td style="text-align:left">格式化无符号整型</td>
</tr>
<tr>
<td style="text-align:left">%o</td>
<td style="text-align:left">格式化无符号八进制数</td>
</tr>
<tr>
<td style="text-align:left">%x</td>
<td style="text-align:left">格式化无符号十六进制数</td>
</tr>
<tr>
<td style="text-align:left">%X</td>
<td style="text-align:left">格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td style="text-align:left">%f</td>
<td style="text-align:left">格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td style="text-align:left">%e</td>
<td style="text-align:left">用科学计数法格式化浮点数</td>
</tr>
<tr>
<td style="text-align:left">%E</td>
<td style="text-align:left">作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td style="text-align:left">%g</td>
<td style="text-align:left">%f和%e的简写</td>
</tr>
<tr>
<td style="text-align:left">%G</td>
<td style="text-align:left">%f 和 %E 的简写</td>
</tr>
<tr>
<td style="text-align:left">%p</td>
<td style="text-align:left">用十六进制数格式化变量的地址</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">定义宽度或者小数点精度</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">用做左对齐</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">在正数前面显示加号( + )</td>
</tr>
<tr>
<td style="text-align:left"><sp></td>
<td style="text-align:left">在正数前面显示空格</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">显示的数字前面填充'0'而不是默认的空格</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">'%%'输出一个单一的'%'</td>
</tr>
<tr>
<td style="text-align:left">(var)</td>
<td style="text-align:left">映射变量(字典参数)</td>
</tr>
<tr>
<td style="text-align:left">m.n.</td>
<td style="text-align:left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>
</tr>
</tbody>
</table>
<p>例子6：<a href="https://blog.csdn.net/qq_44168690/article/details/104116406">Python中print的骚操作(倒计时、转圈显示、进度条)</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.runoob.com/python/att-string-format.html">1. Python format 格式化函数</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://www.runoob.com/w3cnote/python3-print-func-b.html">2. Python3 print 函数用法总结</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 日志模块 logging]]></title>
        <id>https://numantia.github.io/post/python-modules-logging/</id>
        <link href="https://numantia.github.io/post/python-modules-logging/">
        </link>
        <updated>2021-06-15T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#1-%E7%AE%80%E4%BB%8B-python-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%9D%97">1. 简介 Python 日志记录模块</a>
<ul>
<li><a href="#11-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">1.1 日志记录的重要性</a></li>
<li><a href="#12-logging%E6%A8%A1%E5%9D%97%E4%BC%98%E7%82%B9">1.2 Logging模块优点</a></li>
<li><a href="#13-%E5%B8%B8%E7%94%A8%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E6%AF%94%E8%BE%83">1.3 常用日志模块比较</a></li>
</ul>
</li>
<li><a href="#2-logging-%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B5%81">2. Logging 模块组成和工作流</a>
<ul>
<li><a href="#21-logging-%E6%A8%A1%E5%9D%97%E7%BB%84%E6%88%90">2.1 Logging 模块组成</a>
<ul>
<li><a href="#211-logging-%E6%A8%A1%E5%9D%97%E7%B1%BB">2.1.1 Logging 模块类</a></li>
<li><a href="#212-logging-%E6%A8%A1%E5%9D%97%E5%B1%82%E7%BA%A7%E5%87%BD%E6%95%B0">2.1.2 Logging 模块层级函数</a></li>
</ul>
</li>
<li><a href="#22-logging-%E5%B7%A5%E4%BD%9C%E6%B5%81">2.2 Logging 工作流</a></li>
<li><a href="#23-logging-%E9%85%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%B5%81">2.3 Logging 配置工作流</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%951loggingbasicconfig">方法1：logging.basicConfig()</a></li>
<li><a href="#%E6%96%B9%E6%B3%952%E7%9B%B4%E6%8E%A5-python-%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95">方法2：直接 Python 代码调用配置方法</a></li>
<li><a href="#%E6%96%B9%E6%B3%953%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9fileconfig">方法3：创建配置文件，从文件中读取配置内容（<code>fileConfig()</code> ）</a></li>
<li><a href="#%E6%96%B9%E6%B3%954%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AD%97%E5%85%B8yaml-json%E4%BB%8E%E5%AD%97%E5%85%B8%E4%B8%AD%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9dictconfig">方法4：创建配置文件字典(YAML, JSON)，从字典中读取配置内容（<code>dictConfig()</code>）</a></li>
</ul>
</li>
<li><a href="#24-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">2.4 简单的例子</a></li>
</ul>
</li>
<li><a href="#3-logging-%E6%A8%A1%E5%9D%97%E7%94%A8%E6%B3%95">3. Logging 模块用法</a>
<ul>
<li><a href="#31-%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E5%88%B0%E6%96%87%E4%BB%B6%E5%92%8C%E5%B1%8F%E5%B9%95">3.1 日志写入到文件和屏幕</a></li>
<li><a href="#32-%E5%A4%9A%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BAlogging-from-multiple-modules">3.2 多模块输出（Logging from multiple modules）</a></li>
<li><a href="#33-logging-%E8%AE%B0%E5%BD%95-traceback-%E4%BF%A1%E6%81%AF">3.3 Logging 记录 Traceback 信息</a></li>
<li><a href="#34-%E8%BE%93%E5%87%BA%E8%BF%9B%E5%BA%A6%E4%BF%A1%E6%81%AF">3.4 输出进度信息</a></li>
</ul>
</li>
</ul>
</p>
<p>[TOC]</p>
<h1 id="1-简介-python-日志记录模块">1. 简介 Python 日志记录模块</h1>
<h2 id="11-日志记录的重要性">1.1 日志记录的重要性</h2>
<ol>
<li>部署到生产环境中的程序黑箱运行，无法通过调试程序来检查出现的问题，通过观察问题现象来调试，无法精准复现问题，修复问题棘手，会消耗大量时间</li>
<li>日志文件记录相关的时间记录，状态记录，错误记录等信息，方便地追踪运行状况，快速排查问题。</li>
</ol>
<h2 id="12-logging模块优点">1.2 Logging模块优点</h2>
<ol>
<li>
<p>方便日志按重要程度分级管理<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
</li>
<li>
<p>方便日志信息管理（额外日志信息的记录，如时间、运行模块信息）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
</li>
</ol>
<h2 id="13-常用日志模块比较">1.3 常用日志模块比较</h2>
<img src="https://numantia.github.io/post-images/log-recording-modules-comparison.jpg" alt="log-recording-modules-comparison" style="zoom:80%;float:center;" />
<p>​                                                                     图片摘自<a href="https://zhuanlan.zhihu.com/p/339961421">python输出日志</a></p>
<ul>
<li>print : 更加使用程序快速打印，不在乎日志格式，只想更快看到结果 ，一般用于程序的某个片段或者单点进行调试输出 。</li>
<li>pprint: 对元组，列表，字典数据打印更加直观友好，若输出的是这种格式，可以优先考虑pprint .</li>
<li>logging :对实现一个系统或框架时比较合适 ，且对日志需求有更高要求，可以优先考虑logging</li>
<li>loguru ：对实现一个系统或框架也比较合适 ，但是更加轻量化，不需要配置 ，若对日志需求要求不高，可优先考虑loguru</li>
</ul>
<h1 id="2-logging-模块组成和工作流">2. Logging 模块组成和工作流</h1>
<h2 id="21-logging-模块组成">2.1 Logging 模块组成</h2>
<ul>
<li>Logger：即 Logger Main Class，日志记录时创建的对象，我们可以调用Logger的方法传入日志模板和信息，来生成一条条日志记录，称作 Log Record。</li>
<li>Log Record：就代指生成的一条条日志记录。</li>
<li>Handler：处理日志记录的类，它可以将 Log Record 输出到指定的日志位置和存储形式等。</li>
<li>Formatter：生成的 Log Record 也是对象，输出日志文本的话，就需要有一个格式化的过程，那么这个过程就由 Formatter 来完成，返回的就是日志字符串，然后传回给 Handler 来处理。</li>
<li>Filter：保存前过滤，保存想要的日志，如只保存某个级别的日志，或只保存包含某个关键字的日志等，那么这个过滤过程就交给 Filter 来完成。</li>
</ul>
<p>以上就是整个 logging 模块的基本架构和对象功能<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，下面对Logging模块的对象及方法做简要的组成说明，详细参考[<a href="https://docs.python.org/3/library/logging.html#module-logging"><code>logging</code></a> — Logging facility for Python]</p>
<h3 id="211-logging-模块类">2.1.1 Logging 模块类</h3>
<pre><code class="language-bash">&gt;&gt;&gt; dir(logging.Logger)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_log', 'addFilter', 'addHandler', 'callHandlers', 'critical', 'debug', 'error', 'exception', 'fatal', 'filter', 'findCaller', 'getChild', 'getEffectiveLevel', 'handle', 'hasHandlers', 'info', 'isEnabledFor', 'log', 'makeRecord', 'manager', 'removeFilter', 'removeHandler', 'root', 'setLevel', 'warn', 'warning']
&gt;&gt;&gt; dir(logging.Handler)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'acquire', 'addFilter', 'close', 'createLock', 'emit', 'filter', 'flush', 'format', 'get_name', 'handle', 'handleError', 'name', 'release', 'removeFilter', 'setFormatter', 'setLevel', 'set_name']
&gt;&gt;&gt; dir(logging.Formatter)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'converter', 'default_msec_format', 'default_time_format', 'format', 'formatException', 'formatMessage', 'formatStack', 'formatTime', 'usesTime']
&gt;&gt;&gt; dir(logging.Filter)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'filter']
</code></pre>
<h3 id="212-logging-模块层级函数">2.1.2 Logging 模块层级函数</h3>
<p><code>logging.getLogger(name=None)</code></p>
<p><code>logging.getLoggerClass()</code></p>
<p><code>logging.debug(msg, *args, **kwargs)</code></p>
<p><code>logging.info(msg, *args, **kwargs)</code></p>
<p><code>logging.warning(msg, *args, **kwargs)</code></p>
<p><code>logging.error(msg, *args, **kwargs)</code></p>
<p><code>logging.critical(msg, *args, **kwargs)</code></p>
<p><code>logging.exception(msg, *args, **kwargs)</code></p>
<p><code>logging.basicConfig(**kwargs)</code></p>
<p><strong>Logging Level</strong></p>
<pre><code class="language-python">logger = logging.getLogger('simple_example')
logger.setLevel(logging.DEBUG)
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">Level</th>
<th style="text-align:left">When it’s used</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>DEBUG</code></td>
<td style="text-align:left">Detailed information, typically of interest only when diagnosing problems.</td>
</tr>
<tr>
<td style="text-align:left"><code>INFO</code></td>
<td style="text-align:left">Confirmation that things are working as expected.</td>
</tr>
<tr>
<td style="text-align:left"><code>WARNING</code></td>
<td style="text-align:left">An indication that something unexpected happened, or indicative of some problem in the near future (e.g. ‘disk space low’). The software is still working as expected.</td>
</tr>
<tr>
<td style="text-align:left"><code>ERROR</code></td>
<td style="text-align:left">Due to a more serious problem, the software has not been able to perform some function.</td>
</tr>
<tr>
<td style="text-align:left"><code>CRITICAL</code></td>
<td style="text-align:left">A serious error, indicating that the program itself may be unable to continue running.</td>
</tr>
</tbody>
</table>
<p><strong>LogRecord attributes</strong></p>
<pre><code class="language-python">formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">Attribute name</th>
<th style="text-align:left">Format</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">args</td>
<td style="text-align:left">You shouldn’t need to format this yourself.</td>
<td style="text-align:left">The tuple of arguments merged into <code>msg</code> to produce <code>message</code>, or a dict whose values are used for the merge (when there is only one argument, and it is a dictionary).</td>
</tr>
<tr>
<td style="text-align:left">asctime</td>
<td style="text-align:left"><code>%(asctime)s</code></td>
<td style="text-align:left">Human-readable time when the <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> was created. By default this is of the form ‘2003-07-08 16:49:45,896’ (the numbers after the comma are millisecond portion of the time).</td>
</tr>
<tr>
<td style="text-align:left">created</td>
<td style="text-align:left"><code>%(created)f</code></td>
<td style="text-align:left">Time when the <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> was created (as returned by <a href="https://docs.python.org/3/library/time.html#time.time"><code>time.time()</code></a>).</td>
</tr>
<tr>
<td style="text-align:left">exc_info</td>
<td style="text-align:left">You shouldn’t need to format this yourself.</td>
<td style="text-align:left">Exception tuple (à la <code>sys.exc_info</code>) or, if no exception has occurred, <code>None</code>.</td>
</tr>
<tr>
<td style="text-align:left">filename</td>
<td style="text-align:left"><code>%(filename)s</code></td>
<td style="text-align:left">Filename portion of <code>pathname</code>.</td>
</tr>
<tr>
<td style="text-align:left">funcName</td>
<td style="text-align:left"><code>%(funcName)s</code></td>
<td style="text-align:left">Name of function containing the logging call.</td>
</tr>
<tr>
<td style="text-align:left">levelname</td>
<td style="text-align:left"><code>%(levelname)s</code></td>
<td style="text-align:left">Text logging level for the message (<code>'DEBUG'</code>, <code>'INFO'</code>, <code>'WARNING'</code>, <code>'ERROR'</code>, <code>'CRITICAL'</code>).</td>
</tr>
<tr>
<td style="text-align:left">levelno</td>
<td style="text-align:left"><code>%(levelno)s</code></td>
<td style="text-align:left">Numeric logging level for the message (<code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>).</td>
</tr>
<tr>
<td style="text-align:left">lineno</td>
<td style="text-align:left"><code>%(lineno)d</code></td>
<td style="text-align:left">Source line number where the logging call was issued (if available).</td>
</tr>
<tr>
<td style="text-align:left">message</td>
<td style="text-align:left"><code>%(message)s</code></td>
<td style="text-align:left">The logged message, computed as <code>msg % args</code>. This is set when <a href="https://docs.python.org/3/library/logging.html#logging.Formatter.format"><code>Formatter.format()</code></a> is invoked.</td>
</tr>
<tr>
<td style="text-align:left">module</td>
<td style="text-align:left"><code>%(module)s</code></td>
<td style="text-align:left">Module (name portion of <code>filename</code>).</td>
</tr>
<tr>
<td style="text-align:left">msecs</td>
<td style="text-align:left"><code>%(msecs)d</code></td>
<td style="text-align:left">Millisecond portion of the time when the <a href="https://docs.python.org/3/library/logging.html#logging.LogRecord"><code>LogRecord</code></a> was created.</td>
</tr>
<tr>
<td style="text-align:left">msg</td>
<td style="text-align:left">You shouldn’t need to format this yourself.</td>
<td style="text-align:left">The format string passed in the original logging call. Merged with <code>args</code> to produce <code>message</code>, or an arbitrary object (see <a href="https://docs.python.org/3/howto/logging.html#arbitrary-object-messages">Using arbitrary objects as messages</a>).</td>
</tr>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left"><code>%(name)s</code></td>
<td style="text-align:left">Name of the logger used to log the call.</td>
</tr>
<tr>
<td style="text-align:left">pathname</td>
<td style="text-align:left"><code>%(pathname)s</code></td>
<td style="text-align:left">Full pathname of the source file where the logging call was issued (if available).</td>
</tr>
<tr>
<td style="text-align:left">process</td>
<td style="text-align:left"><code>%(process)d</code></td>
<td style="text-align:left">Process ID (if available).</td>
</tr>
<tr>
<td style="text-align:left">processName</td>
<td style="text-align:left"><code>%(processName)s</code></td>
<td style="text-align:left">Process name (if available).</td>
</tr>
<tr>
<td style="text-align:left">relativeCreated</td>
<td style="text-align:left"><code>%(relativeCreated)d</code></td>
<td style="text-align:left">Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.</td>
</tr>
<tr>
<td style="text-align:left">stack_info</td>
<td style="text-align:left">You shouldn’t need to format this yourself.</td>
<td style="text-align:left">Stack frame information (where available) from the bottom of the stack in the current thread, up to and including the stack frame of the logging call which resulted in the creation of this record.</td>
</tr>
<tr>
<td style="text-align:left">thread</td>
<td style="text-align:left"><code>%(thread)d</code></td>
<td style="text-align:left">Thread ID (if available).</td>
</tr>
<tr>
<td style="text-align:left">threadName</td>
<td style="text-align:left"><code>%(threadName)s</code></td>
<td style="text-align:left">Thread name (if available).</td>
</tr>
</tbody>
</table>
<h2 id="22-logging-工作流">2.2 Logging 工作流</h2>
<img src="https://numantia.github.io/post-images/logging_flow.png" alt="logging_flow.png" style="zoom:80%;" />
<p>​                                                                  图片摘自官网<a href="https://docs.python.org/3/howto/logging.html#logging-flow">logging-basic-tutorial</a></p>
<h2 id="23-logging-配置工作流">2.3 Logging 配置工作流</h2>
<p>配置 logging 有四种方法</p>
<h3 id="方法1loggingbasicconfig">方法1：logging.basicConfig()</h3>
<pre><code class="language-python">&quot;&quot;&quot;
logging.basicConfig(
    filename,
    filemode,
    format,
    datefmt,
    style,
    level,
    stream,
    handlers
)
&quot;&quot;&quot;
import logging

_format = ('%(asctime)s '
           '%(name)s '  # the name of logger
           '%(levelname)s '
           '%(filename)s '
           '%(threadName)s '
           '%(lineno)d: '
           '%(message)s')
logging.basicConfig(
    level=logging.DEBUG,  # 默认 level 是 WARNING
    filename='test.log',
    format=_format,
)

logging.debug('logging debug')
logging.info('logging info')

</code></pre>
<h3 id="方法2直接-python-代码调用配置方法">方法2：直接 Python 代码调用配置方法</h3>
<img src="https://numantia.github.io/post-images/image-20210615161943846.png" alt="image-20210615161943846" style="zoom:80%;" />
<pre><code class="language-python">import logging

# create logger
logger = logging.getLogger('simple_example')
logger.setLevel(logging.DEBUG)

# create console handler and set level to debug
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

# create formatter
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# add formatter to ch
ch.setFormatter(formatter)

# add ch to logger
logger.addHandler(ch)

# 'application' code
logger.debug('debug message')
logger.info('info message')
logger.warning('warn message')
logger.error('error message')
logger.critical('critical message')
</code></pre>
<h3 id="方法3创建配置文件从文件中读取配置内容fileconfig">方法3：创建配置文件，从文件中读取配置内容（<a href="https://docs.python.org/3/library/logging.config.html#logging.config.fileConfig"><code>fileConfig()</code></a> ）</h3>
<pre><code class="language-python">import logging
import logging.config

logging.config.fileConfig('logging.conf')

# create logger
logger = logging.getLogger('simpleExample')

# 'application' code
logger.debug('debug message')
logger.info('info message')
logger.warning('warn message')
logger.error('error message')
logger.critical('critical message')
</code></pre>
<p>logging.conf (使用配置文件需去除批注)</p>
<pre><code class="language-bash">[loggers]
keys=root,simpleExample

[handlers]
keys=consoleHandler

[formatters]
keys=simpleFormatter

##########################################################
[logger_root] # 定义 root 的日志器，logger_key1
level=DEBUG
handlers=consoleHandler # 继承自[handlers]中key

[logger_simpleExample] # 定义 simpleExample 的日志器,logger_key2
level=DEBUG
handlers=consoleHandler
qualname=simpleExample # 继承自[loggers]中key
propagate=0

[handler_consoleHandler] # 定义窗口输出的处理器,handlers_key1
class=StreamHandler
level=DEBUG
formatter=simpleFormatter # 继承自[formatters]中key
args=(sys.stdout,)

[formatter_simpleFormatter] # 定义格式器，formatters_key1
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s
</code></pre>
<h3 id="方法4创建配置文件字典yaml-json从字典中读取配置内容dictconfig">方法4：创建配置文件字典(YAML, JSON)，从字典中读取配置内容（<a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig"><code>dictConfig()</code></a>）</h3>
<pre><code class="language-python">def setup_logging(default_path = &quot;config/logging.json&quot;, default_level = logging.INFO,env_key = &quot;LOG_CFG&quot;):
    path = default_path
    value = os.getenv(env_key,None)
    if value:
        path = value
    if os.path.exists(path):
        with open(path,&quot;r&quot;) as f:
            config = json.load(f)
            logging.config.dictConfig(config)
    else:
        logging.basicConfig(level = default_level)

if __name__ == '__main__':
    setup_logging(default_path = &quot;config/logging.json&quot;)
    main()
</code></pre>
<p><strong>配置文件：YAML format dictionary</strong></p>
<pre><code class="language-yaml">version: 1
formatters:
  simple:
    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
handlers:
  console:
    class: logging.StreamHandler
    level: DEBUG
    formatter: simple
    stream: ext://sys.stdout
loggers:
  simpleExample:
    level: DEBUG
    handlers: [console]
    propagate: no
root:
  level: DEBUG
  handlers: [console]
</code></pre>
<p><strong>配置文件：JSON format dictionary</strong> （去除#后内容方可使用）</p>
<pre><code class="language-json">{
    &quot;version&quot;:1,
    &quot;disable_existing_loggers&quot;:false,
    &quot;formatters&quot;:{
        &quot;simple&quot;:{
            &quot;format&quot;:&quot;%(asctime)s - %(name)s - %(filename)s  - %(funcName)s - %(lineno)d- %(levelname)s - %(message)s&quot;
        }
    },
    &quot;handlers&quot;:{
        &quot;console&quot;:{
            &quot;class&quot;:&quot;logging.StreamHandler&quot;,
            &quot;level&quot;:&quot;DEBUG&quot;, # 设置 handlers 的输出级别，下一级
            &quot;formatter&quot;:&quot;simple&quot;,
            &quot;stream&quot;:&quot;ext://sys.stdout&quot;
        },
        &quot;info_file_handler&quot;:{
            &quot;class&quot;:&quot;logging.handlers.RotatingFileHandler&quot;,
            &quot;level&quot;:&quot;INFO&quot;, # 设置 handlers 的输出级别，下一级
            &quot;formatter&quot;:&quot;simple&quot;,
            &quot;filename&quot;:&quot;log/info.log&quot;,
            &quot;maxBytes&quot;:40960,
            &quot;backupCount&quot;:20,
            &quot;encoding&quot;:&quot;utf8&quot;
        },
        &quot;error_file_handler&quot;:{
            &quot;class&quot;:&quot;logging.handlers.RotatingFileHandler&quot;,
            &quot;level&quot;:&quot;ERROR&quot;, # 设置 handlers 的输出级别，下一级
            &quot;formatter&quot;:&quot;simple&quot;,
            &quot;filename&quot;:&quot;log/errors.log&quot;,
            &quot;maxBytes&quot;:40960, # 单个文件大小 1024*40
            &quot;backupCount&quot;:20, #备份文件数目 20个文件
            &quot;encoding&quot;:&quot;utf8&quot;
        }
    },
    &quot;loggers&quot;:{
        &quot;my_module&quot;:{
            &quot;level&quot;:&quot;ERROR&quot;, # 设置 Logger 的输出级别
            &quot;handlers&quot;:[&quot;info_file_handler&quot;],
            &quot;propagate&quot;:&quot;no&quot;
        }
    },
    &quot;root&quot;:{
        &quot;level&quot;:&quot;INFO&quot;,
        &quot;handlers&quot;:[&quot;console&quot;,&quot;info_file_handler&quot;,&quot;error_file_handler&quot;]
    }
}
</code></pre>
<h2 id="24-简单的例子">2.4 简单的例子</h2>
<pre><code class="language-python">import logging
import logging.handlers

logger = logging.getLogger('test')
logger.setLevel(level=logging.DEBUG)  # 记录日志的级别
&quot;&quot;&quot;
%(name)s：Logger的名字
%(levelno)s：打印日志级别的数值
%(levelname)s：打印日志级别的名称
%(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]
%(filename)s：打印当前执行程序名
%(funcName)s：打印日志的当前函数
%(lineno)d：打印日志的当前行号
%(asctime)s：打印日志的时间
%(thread)d：打印线程ID
%(threadName)s：打印线程名称
%(process)d：打印进程ID
%(message)s：打印日志信息
&quot;&quot;&quot;

formatter = logging.Formatter('%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')
&quot;&quot;&quot;
logging.StreamHandler -&gt; 控制台输出
logging.FileHandler -&gt; 文件输出
logging.handlers.RotatingFileHandler -&gt; 按照大小自动分割日志文件，一旦达到指定的大小重新生成文件
logging.handlers.TimedRotatingFileHandler -&gt; 按照时间自动分割日志文件
&quot;&quot;&quot;
file_handler = logging.FileHandler('log/test.log') # 输出文件日志的位置方式，添加文件位置
file_handler.setLevel(level=logging.INFO) # 输出文件日志的级别 
file_handler.setFormatter(formatter) # 输出文件日志的格式

stream_handler = logging.StreamHandler() # 输出屏幕日志的位置方式
stream_handler.setLevel(logging.DEBUG) # 输出屏幕日志的级别
stream_handler.setFormatter(formatter) # 输出屏幕日志的格式

# time_rotating_file_handler = logging.handlers.TimedRotatingFileHandler(filename='rotating_test.log', when='D')
# time_rotating_file_handler.setLevel(logging.DEBUG)
# time_rotating_file_handler.setFormatter(formatter)

logger.addHandler(file_handler)
logger.addHandler(stream_handler)
# logger.addHandler(time_rotating_file_handler)

# 运行测试
logger.debug('debug级别，一般用来打印一些调试信息，级别最低')
logger.info('info级别，一般用来打印一些正常的操作信息')
logger.warning('waring级别，一般用来打印警告信息')
logger.error('error级别，一般用来打印一些错误信息')
logger.critical('critical级别，一般用来打印一些致命的错误信息，等级最高')
</code></pre>
<h1 id="3-logging-模块用法">3. Logging 模块用法</h1>
<h2 id="31-日志写入到文件和屏幕">3.1 日志写入到文件和屏幕</h2>
<p>输出到文件：设置logging，创建一个FileHandler，并对输出消息的格式进行设置，将其添加到logger，然后将日志写入到指定的文件中</p>
<p>输出到屏幕： logger中添加StreamHandler，可以将日志输出到屏幕上</p>
<p>其他不同的 Handler 方式</p>
<pre><code>StreamHandler：logging.StreamHandler；日志输出到流，可以是sys.stderr，sys.stdout或者文件
FileHandler：logging.FileHandler；日志输出到文件
BaseRotatingHandler：logging.handlers.BaseRotatingHandler；基本的日志回滚方式
RotatingHandler：logging.handlers.RotatingHandler；日志回滚方式，支持日志文件最大数量和日志文件回滚
TimeRotatingHandler：logging.handlers.TimeRotatingHandler；日志回滚方式，在一定时间区域内回滚日志文件
SocketHandler：logging.handlers.SocketHandler；远程输出日志到TCP/IP sockets
DatagramHandler：logging.handlers.DatagramHandler；远程输出日志到UDP sockets
SMTPHandler：logging.handlers.SMTPHandler；远程输出日志到邮件地址
SysLogHandler：logging.handlers.SysLogHandler；日志输出到syslog
NTEventLogHandler：logging.handlers.NTEventLogHandler；远程输出日志到Windows NT/2000/XP的事件日志
MemoryHandler：logging.handlers.MemoryHandler；日志输出到内存中的指定buffer
HTTPHandler：logging.handlers.HTTPHandler；通过&quot;GET&quot;或者&quot;POST&quot;远程输出到HTTP服务器
</code></pre>
<p>同时输出达到屏幕和文件可参考下一节。</p>
<h2 id="32-多模块输出logging-from-multiple-modules">3.2 多模块输出（<a href="https://docs.python.org/3/howto/logging.html#logging-from-multiple-modules">Logging from multiple modules</a>）</h2>
<p><strong>例子1：</strong> 最简单例子解释使用模式</p>
<pre><code class="language-python"># myapp.py
import logging
import mylib

def main():
    logging.basicConfig(filename='myapp.log', level=logging.INFO)
    logging.info('Started')
    mylib.do_something()
    logging.info('Finished')

if __name__ == '__main__':
    main()
</code></pre>
<pre><code class="language-python">    # mylib.py
    import logging

    def do_something():
        logging.info('Doing something')
</code></pre>
<pre><code class="language-cmd">输出
&gt;&gt;&gt; 
INFO:root:Started
INFO:root:Doing something
INFO:root:Finished
</code></pre>
<p><strong>例子2：</strong> 多模块追踪信息来源<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<pre><code class="language-python"># mainModule.py

import logging
import subModule
logger = logging.getLogger(&quot;mainModule&quot;) # 主模块定义了logger'mainModule'，在python解释器进程其他模块里都可以使用logger对象，不需要反复的定义和配置各个模块的logger
logger.setLevel(level = logging.INFO)
handler = logging.FileHandler(&quot;log.txt&quot;)
handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
 
console = logging.StreamHandler()
console.setLevel(logging.INFO)
console.setFormatter(formatter)
 
logger.addHandler(handler)
logger.addHandler(console)
 
 
logger.info(&quot;creating an instance of subModule.subModuleClass&quot;)
a = subModule.SubModuleClass()
logger.info(&quot;calling subModule.subModuleClass.doSomething&quot;)
a.doSomething()
logger.info(&quot;done with  subModule.subModuleClass.doSomething&quot;)
logger.info(&quot;calling subModule.some_function&quot;)
subModule.som_function()
logger.info(&quot;done with subModule.some_function&quot;)
</code></pre>
<pre><code class="language-python">import logging
 
module_logger = logging.getLogger(&quot;mainModule.sub&quot;) # 任意以'mainModule'开头的logger都是它的子logger
class SubModuleClass(object):
    def __init__(self):
        self.logger = logging.getLogger(&quot;mainModule.sub.module&quot;)
        self.logger.info(&quot;creating an instance in SubModuleClass&quot;)
    def doSomething(self):
        self.logger.info(&quot;do something in SubModule&quot;)
        a = []
        a.append(1)
        self.logger.debug(&quot;list a = &quot; + str(a))
        self.logger.info(&quot;finish something in SubModuleClass&quot;)
 
def som_function():
    module_logger.info(&quot;call function some_function&quot;)
</code></pre>
<pre><code class="language-cmd">输出
&gt;&gt;&gt;
2016-10-09 20:25:42,276 - mainModule - INFO - creating an instance of subModule.subModuleClass
2016-10-09 20:25:42,279 - mainModule.sub.module - INFO - creating an instance in SubModuleClass
2016-10-09 20:25:42,279 - mainModule - INFO - calling subModule.subModuleClass.doSomething
2016-10-09 20:25:42,279 - mainModule.sub.module - INFO - do something in SubModule
2016-10-09 20:25:42,279 - mainModule.sub.module - INFO - finish something in SubModuleClass
2016-10-09 20:25:42,279 - mainModule - INFO - done with  subModule.subModuleClass.doSomething
2016-10-09 20:25:42,279 - mainModule - INFO - calling subModule.some_function
2016-10-09 20:25:42,279 - mainModule.sub - INFO - call function some_function
2016-10-09 20:25:42,279 - mainModule - INFO - done with subModule.some_function
</code></pre>
<h2 id="33-logging-记录-traceback-信息">3.3 Logging 记录 Traceback 信息</h2>
<p>Python中的traceback模块被用于跟踪异常返回信息，可以在logging中记录下traceback.改部分摘自参考文章<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>。</p>
<pre><code class="language-python">import logging
logger = logging.getLogger(__name__)
logger.setLevel(level = logging.INFO)
handler = logging.FileHandler(&quot;log.txt&quot;)
handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
 
console = logging.StreamHandler()
console.setLevel(logging.INFO)
 
logger.addHandler(handler)
logger.addHandler(console)
 
logger.info(&quot;Start print log&quot;)
logger.debug(&quot;Do something&quot;)
logger.warning(&quot;Something maybe fail.&quot;)
try:
    open(&quot;sklearn.txt&quot;,&quot;rb&quot;)
except (SystemExit,KeyboardInterrupt):
    raise
except Exception:
    logger.error(&quot;Faild to open sklearn.txt from logger.error&quot;,exc_info = True) # 方法1
    logger.exception(&quot;Failed to open sklearn.txt from logger.exception&quot;) # 方法2
 
logger.info(&quot;Finish&quot;)
</code></pre>
<pre><code>Start print log
Something maybe fail.
Faild to open sklearn.txt from logger.error
Traceback (most recent call last):
  File &quot;G:\zhb7627\Code\Eclipse WorkSpace\PythonTest\test.py&quot;, line 23, in &lt;module&gt;
    open(&quot;sklearn.txt&quot;,&quot;rb&quot;)
IOError: [Errno 2] No such file or directory: 'sklearn.txt'
Finish
</code></pre>
<h2 id="34-输出进度信息">3.4 输出进度信息</h2>
<pre><code class="language-python">logging.info(&quot;Operating progress: {:.1f}%, {} &quot;.format(num/cycle_No*100, &quot;&gt;&quot; * (num // 2)))
</code></pre>
<p>https://zhuanlan.zhihu.com/p/56095714</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://docs.python.org/3/library/logging.html#logging-levels">1. Logging Levels</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://docs.python.org/3/library/logging.html#logrecord-attributes">2. logrecord-attributes</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://blog.csdn.net/pansaky/article/details/90710751?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162322535616780269881668%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162322535616780269881668&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-8-90710751.first_rank_v2_pc_rank_v29&amp;utm_term=python+%E6%97%A5%E5%BF%97&amp;spm=1018.2226.3001.4187">3.python 日志 logging模块(详细解析)</a> <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a href="https://cuiqingcai.com/6080.html">4. Python 中 logging 模块的基本用法</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 文件夹操作]]></title>
        <id>https://numantia.github.io/post/python-dir-operation/</id>
        <link href="https://numantia.github.io/post/python-dir-operation/">
        </link>
        <updated>2021-06-14T18:09:44.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">import os, re, shutil

class  file_operation(object):
    def __init__(self, file_dir='.', layer=1):
        &quot;&quot;&quot;[file operation initilization]

        Parameters
        ----------
        file_dir : str, optional
            [objective directory path], by default '.'
        &quot;&quot;&quot;
        self.file_dir = file_dir
        self.layer = layer
        
    def get_files(self):
        &quot;&quot;&quot;[Only get filepath name in the specified directory exculde files in the sub-directory]

        Parameters
        ----------
        None

        Returns
        -------
        [str list]
            [return filelists]
        &quot;&quot;&quot;
 
        # check whether filr_dir is None
        if self.file_dir == None:
            self.file_dir = os.getcwd()
        
        if self.layer == 1:
            list_both = os.listdir(self.file_dir)  
            # read files and directories both at first level of directory
            rel_filelist = [item for item in list_both if os.path.isfile(os.path.join(self.file_dir, item))]
            abs_filelist = [os.path.join(self.file_dir,item) for item in list_both if os.path.isfile(os.path.join(self.file_dir, item))]
            # os.path.isfile 接收的参数是路径+文件名 
            # os.path 模块稍后会讲到
        if self.layer == 2:
            # Iterate through all folders including sub-directory
            rel_filelist = []
            abs_filelist = []
            for filepath,dirnames,filenames in os.walk(self.file_dir):
                for filename in filenames:
                    rel_filelist.append(filename)
                    abs_filelist.append(os.path.join(filepath,filename))
        return rel_filelist, abs_filelist
    
    def get_fotmatted_files(self, file_format=['.csv']):
        &quot;&quot;&quot;[Only get specied formatted filepath name in the specified directory exculde files in the sub-directory]

        Parameters
        ----------
        file_dir : str, optional
            [current file directory path], by default '.'

        Returns
        -------
        [str list]
            [return filelist_filt]
        &quot;&quot;&quot;
        rel_filelist, abs_filelist = file_operation.get_files(self)
        filelist_filt = [file for file in abs_filelist if os.path.splitext(file)[1] in file_format]
        return filelist_filt
    
    def make_dir(self, file_format, regex, group_num=1):
        abs_filelist = file_operation.get_fotmatted_files(self, file_format)
        match_no_duplicate  = []
        for item in abs_filelist:
            match = regex.search(item).group(group_num)
            if match not in match_no_duplicate:
                match_no_duplicate.append(match)
                os.mkdir(os.path.join(self.file_dir, match))
                print(&quot;{} 文件夹已创建&quot;.format(match))

    def move_file(self, out_dir, abs_filelist, regex, group_num=1):
        &quot;&quot;&quot;[usuage 01: filter filelist using regular expression, move filtered files into predefined directory]

        Parameters
        ----------
        out_dir : [type]
            [description]
        abs_filelist : [type]
            [description]
        regex : [re]
            [regular expression]
        group_num : int, optional
            [group No], by default 1
        &quot;&quot;&quot;
        print(self.file_dir)
        for item in abs_filelist:
            try:
                match = regex.search(item).group(group_num)
                src = os.path.join(self.file_dir, match)
                dst = out_dir
                print('src:', src)
                print('dst:', dst)
                shutil.copy(src, dst)
            except:
                print(&quot;{}文件不匹配&quot;.format(item))
                continue
    
    def mkdir_move_file(self, file_format, regex, group_num=1):
        &quot;&quot;&quot;[usuage 02: iterate over each of file, move them to corresponding directory]

        Parameters
        ----------
        file_format : [str list]
            [format string list]
        regex : [re]
            [regular expression]
        group_num : int, optional
            [group No], by default 1
        &quot;&quot;&quot;
        print(self.file_dir)
        abs_filelist = file_operation.get_fotmatted_files(self, file_format)
        file_operation.make_dir(self, file_format,regex,group_num)
        for item in abs_filelist:
            match = regex.search(item).group(group_num)   
            src = item
            dst = os.path.join(self.file_dir, match)
            print('src:', src)
            print('dst:', dst)
            shutil.copy(src, dst)
</code></pre>
<p>https://zhuanlan.zhihu.com/p/150835193</p>
<p>https://blog.csdn.net/CrozonKDD/article/details/79305235</p>
<p>https://blog.csdn.net/silentwolfyh/article/details/74931123</p>
<p>https://blog.csdn.net/u013171226/article/details/107680283</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pip 软件源管理（一次性解决下载缓慢问题）]]></title>
        <id>https://numantia.github.io/post/pip-software-source-management/</id>
        <link href="https://numantia.github.io/post/pip-software-source-management/">
        </link>
        <updated>2021-06-07T04:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="临时修改">临时修改</h1>
<pre><code class="language-bash">pip install tensorflow -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
</code></pre>
<h1 id="pip-config-修改">pip config 修改</h1>
<pre><code class="language-bash"># 清华源
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
# 或：
# 阿里源
pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/
# 腾讯源
pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple
# 豆瓣源
pip config set global.index-url http://pypi.douban.com/simple/
</code></pre>
<h1 id="修改配置文件">修改配置文件</h1>
<pre><code class="language-bash">Linux:
修改 pip.conf 文件 (没有就创建一个)
$HOME/.config/pip/pip.conf
修改内容如下：
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple12

Mac:
修改 pip.conf 文件
$HOME/Library/Application Support/pip/pip.conf
如果没有上面的目录,在如下目录创建 pip.conf
$HOME/.config/pip/pip.conf
修改内容如下：
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple12

Windows:
修改 pip.conf 文件 (没有就创建一个)
%APPDATA%\pip\pip.ini
修改内容如下：
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
]]></content>
    </entry>
</feed>